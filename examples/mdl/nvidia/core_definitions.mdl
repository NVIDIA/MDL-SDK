/***************************************************************************************************
 * Copyright (c) 2015-2025, NVIDIA CORPORATION. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  * Neither the name of NVIDIA CORPORATION nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  * Neither the name of NVIDIA CORPORATION nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 **************************************************************************************************/

// The "//group ... //endgroup" comments are used during the
// procedural creation of this module's documentation.
mdl 1.6;

import ::df::*;
import ::state::*;
import ::math::*;
import ::base::*;
import ::tex::*;
import ::anno::*;
export using ::base import texture_return;
export using ::base import mono_mode;
export using ::base import color_layer_mode;
//import support_definitions::*;
module [[
    anno::version( 2, 0, 2),
    anno::display_name("NVIDIA core definitions")
]];

const string COPYRIGHT = "Copyright 2025 NVIDIA Corporation. All rights reserved.";

//some local functions, dont document
// blend two normals, similar to
// http://blog.selfshadow.com/publications/blending-in-detail/
export float3 blend_normals(
    float3 base_normal = state::normal()
    [[
        anno::description("The base normal")
    ]],
    float base_normal_weight = 1.0f
    [[
        anno::description("Specifies the strength of the base normal using a linear blend between state::normal and \"base_normal\""),
        anno::soft_range(0.0,1.0)
    ]],
    float3 detail_normal = state::normal()
    [[
        anno::description("The detail normal")
    ]],
    float detail_normal_weight = 1.0f
    [[
        anno::description("Specifies the strength of the detail normal using a linear blend between state::normal and \"detail_normal\""),
        anno::soft_range(0.0,1.0)
    ]]
)
[[
    anno::description("Blend two normals or apply a detail normal map"),
    anno::display_name("Blend normals"),
    anno::thumbnail(".thumbs/blend_normals.png"),
    anno::in_group("Texturing, high level"),
    anno::ui_order(33),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT)]]
{
    return base::blend_normals(base_normal,base_normal_weight,detail_normal,detail_normal_weight);
}
// blend 3 normals, similar to
// http://blog.selfshadow.com/publications/blending-in-detail/
//TODO: make public?
float3 blend_3_normals(
    float3 base_normal = state::normal()
        [[
            anno::description("The base normal")
        ]],
    float base_normal_weight = 1.0f
        [[
            anno::description("Specifies the strength of the base normal using a linear blend between state::normal and \"base_normal\"")
        ]],
    float3 detail_normal = state::normal()
        [[
            anno::description("The detail normal")
        ]],
    float detail_normal_weight = 1.0f
        [[
            anno::description("Specifies the strength of the detail normal using a linear blend between state::normal and \"detail_normal\"")
        ]],
    float3 detail_normal2 = state::normal()
        [[
            anno::description("The detail normal2")
        ]],
    float detail_normal_weight2 = 1.0f
        [[
            anno::description("Specifies the strength of the detail normal using a linear blend between state::normal and \"detail_normal\"")
        ]]
)
[[
    anno::description("Blend three normals for sticker-like situations where a detail normal map is applied to a base normal map"),
    anno::noinline()
]]
{
    float3 tu = state::texture_tangent_u(0);
    float3 tv = state::texture_tangent_v(0);
    float3 n = state::normal();

    float w1 = math::saturate(base_normal_weight);
    float w2 = math::saturate(detail_normal_weight);
    float w3 = math::saturate(detail_normal_weight2);

    float3 n1_t = math::normalize(
        float3(math::dot(tu, base_normal) * w1,
               math::dot(tv, base_normal) * w1,
               math::dot(n, base_normal) * w1 + 1.0f - w1));
    float3 n2_t = math::normalize(
        float3(math::dot(tu, detail_normal) * w2,
               math::dot(tv, detail_normal) * w2,
               math::dot(n, detail_normal) * w2 + 1.0f - w2));
    float3 n3_t = math::normalize(
        float3(math::dot(tu, detail_normal2) * w3,
               math::dot(tv, detail_normal2) * w3,
               math::dot(n, detail_normal2) * w3 + 1.0f - w3));

    n1_t.z += 1.0f;
    n2_t.x = -n2_t.x;
    n2_t.y = -n2_t.y;

    float3 n12_t = n1_t * math::dot(n1_t, n2_t) / n1_t.z - n2_t;

    n12_t.z+= 1.0f;
    n3_t.x = -n3_t.x;
    n3_t.y = -n3_t.y;
    float3 n_t = n12_t * math::dot(n12_t, n3_t) / n12_t.z - n3_t;

    return math::normalize(
        tu * n_t.x +
        tv * n_t.y +
        n * n_t.z);
}

float3 transform_rotate(float3 p, float3 r)
{
    // Euler rotation matrix  xyz order to stay compatible with ::base
    float3 s = math::sin(r);
    float3 c = math::cos(r);
    float3x3 rotate =
        float3x3(  c.y*c.z ,  -c.x*s.z + s.x*s.y*c.z ,  s.x*s.z + c.x*s.y*c.z ,
                   c.y*s.z ,   c.x*c.z + s.x*s.y*s.z , -s.x*c.z + c.x*s.y*s.z ,
                  -s.y     ,   s.x*c.y               ,  c.x*c.y               );
    return p*rotate;

}
float3 transform_rotate_inv(float3 p, float3 r)
{
    // Euler rotation matrix  xyz order to stay compatible with ::base
    float3 s = math::sin(r);
    float3 c = math::cos(r);
    float3x3 rotate =
        float3x3(  c.y*c.z ,  -c.x*s.z + s.x*s.y*c.z ,  s.x*s.z + c.x*s.y*c.z ,
                   c.y*s.z ,   c.x*c.z + s.x*s.y*s.z , -s.x*c.z + c.x*s.y*s.z ,
                  -s.y     ,   s.x*c.y               ,  c.x*c.y               );
    return rotate*p;

}
float2 transform_st(float rotation = 0.0, float2 translation = float2(0.0), float2 scale = float2(1.0), float2 st = float2(0.0))
[[
    anno::display_name("Transform 2D"),
    anno::description("Rotate/translate/scale a 2D coordinate"),
    anno::author("NVIDIA Corporation")
]]{
    float s = math::sin(rotation);
        float c = math::cos(rotation);
        float2 st_t=st;
        st_t = float2(s*st_t.x+c*st_t.y,s*st_t.y-c*st_t.x);
        return st_t*scale+ translation;
}

color biased_color_blend(float w1 = 0.0, color c1 = color(0.0), float w2 = 0.0, color c2 = color(0.0), float w3 = 0.0, color c3 = color(0.0), color mean = color(0.5))
[[
    anno::display_name("Biased color blend"),
    anno::description("Blend up to 3 colors. Set mean to the average color to preserve contrast when blending textures"),
    anno::author("NVIDIA Corporation")
]]
{
        color o=w1*c1+w2*c2+w3*c3;
        float s=w1+w2+w3;
        float s2=w1*w1+w2*w2+w3*w3;
return mean + (o-s*mean)/   math::sqrt(s2);
}       


//group Enumerations

export enum material_type
[[
    anno::display_name("User interface group"),
    anno::description("User interface grouping hint for materials"),
    anno::hidden()
]]
{
    simple_material
        [[ anno::description("Simple material") ]],
    complex_material
        [[ anno::description("Complex material") ]],
    combiner_material
        [[ anno::description("Combiner material") ]],
    modifier_material
        [[ anno::description("Material modifier") ]]
};

export enum emission_type
[[
    anno::display_name("Emission mode"),
    anno::description("Emission mode definition for light sources"),
    anno::hidden()
]]
{
    lumen_m2
        [[ anno::description("lumen/m2") ]],
    lumen
        [[ anno::description("lumen") ]],
    candela
        [[ anno::description("candela") ]],
    nit
        [[ anno::description("nit (candela/m2)") ]]
};

export enum cell_type
[[
    anno::display_name("Worley noise cell type"),
    anno::description("Behavior of the Worley noise cell"),
    anno::hidden()
]]
{
    simple_cells = 0
        [[ anno::description("Simple cells") ]],
    crystal_cells = 1
        [[ anno::description("Crystal cells") ]],
    bordered_cells = 2
        [[ anno::description("Bordered cells") ]]
};

export enum cell_base
[[
    anno::display_name("Worley noise cell shape"),
    anno::description("Shape of the Worley noise cell"),
    anno::hidden()
]]
{
    circular_cells = 0
        [[ anno::description("Circle base") ]],
    diamond_cells = 1
        [[ anno::description("Diamond base") ]]
};

//endgroup

float4x4 rotation_translation_scale(
    float3 rotation = float3(0.)
        [[ anno::description("Rotation applied to every UVW coordinate") ]],
    float3 translation = float3(0.)
        [[ anno::description("Offset applied to every UVW coordinate") ]],
    float3 scaling = float3(1.)
        [[ anno::description("Scale applied to every UVW coordinate") ]]
)
[[
    anno::description("Construct transformation matrix from Euler rotation, translation and scale"),
    anno::hidden()
]]
{
    float4x4 scale =
        float4x4(scaling.x     , 0.            , 0.            , 0.,
                 0.            , scaling.y     , 0.            , 0.,
                 0.            , 0.            , scaling.z     , 0.,
                 translation.x , translation.y , translation.z , 1.);

    float3 s = math::sin(rotation);
    float3 c = math::cos(rotation);
    float4x4 rotate =
        float4x4(  c.y*c.z , -c.x*s.z + s.x*s.y*c.z ,  s.x*s.z + c.x*s.y*c.z , 0.0,
                   c.y*s.z ,  c.x*c.z + s.x*s.y*s.z , -s.x*c.z + c.x*s.y*s.z , 0.0,
                  -s.y     ,  s.x*c.y               ,  c.x*c.y               , 0.0,
                   0.      ,  0.                    ,  0.                    , 1.);

    return   scale*rotate;
}

export annotation suitable_as_light();
export annotation type_of_material(material_type type);
export annotation dimension(float dimension);
export annotation dimension(float2 dimension);
export annotation dimension(float3 dimension);


//group Texturing functions

export texture_return blend_colors(
    color color_1 = color(0.0)
    [[ anno::display_name("Color 1") ]],
    color color_2 = color(1.0)
    [[ anno::display_name("Color 2") ]],
    uniform color_layer_mode mode = color_layer_blend
    [[
        anno::description("Describes how Color 1 and Color 2 are combined"),
        anno::display_name("Blend mode")
    ]],
    float weight = 1.
    [[
        anno::description("Defines strength of the effect. At weight 0, only color 1 will be visible. At weight 1, the blend function will have full effect."),
        anno::display_name("Blend weight"),
        anno::soft_range(0.0,1.0)
    ]],
    uniform bool linear_blend = true
    [[
        anno::description("The blend opperation can either be applied in linear or gamma (2.2) color space"),
        anno::display_name("Linear blend")
    ]]
)
[[
    anno::display_name("Blend colors"),
    anno::description("Allows combining textures and colors in varied ways"),
    anno::thumbnail(".thumbs/blend_colors.png"),
    anno::in_group("Texturing, high level"),
    anno::ui_order(33),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT)
]]
{
    color c1 = linear_blend? color_1: math::pow(color_1,0.45);
    color c2 = linear_blend? color_2: math::pow(color_2,0.45);
    float w = linear_blend? weight: math::pow(weight,0.45);
    texture_return r = base::blend_color_layers(
        layers: base::color_layer[](
            base::color_layer(
                layer_color: c2,
                weight: w,
                mode: mode
                )),
        base: c1
    );
    return linear_blend? r: texture_return(math::pow(r.tint,2.2),math::pow(r.mono,2.2));
}

export texture_return file_texture(
    uniform texture_2d texture
    [[
        anno::display_name("Bitmap file"),
        anno::in_group("Bitmap parameters"),
        anno::ui_order(0)
    ]],
    uniform mono_mode mono_source = mono_average
    [[
        anno::display_name("Scalar mode"),
        anno::description("Defines how the texture applies to scalar parameters"),
        anno::in_group("Bitmap parameters"),
        anno::ui_order(1)
    ]],
    uniform float brightness = 1.
    [[
        anno::display_name("Brightness"),
        anno::in_group("Bitmap parameters"),
        anno::ui_order(2),
        anno::soft_range(0.0,1.0)
    ]],
    uniform float contrast = 1.
    [[
        anno::display_name("Contrast"),
        anno::in_group("Bitmap parameters"),
        anno::ui_order(3),
        anno::soft_range(0.0,1.0)
    ]],
    float2 scaling = float2(1.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        anno::ui_order(8)
    ]],
    float2 translation = float2(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        anno::ui_order(7)
    ]],
    float rotation = 0.
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        anno::ui_order(6),
        anno::soft_range(0.0,360.0)
    ]],
    uniform bool clip = false
    [[
        anno::description("If set to true, texture will not repeat. Outside of the texture, color will be black and the scalar value will be 0."),
        anno::display_name("Clip"),
        anno::in_group("Placement"),
        anno::ui_order(9)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Selects a specific UV space"),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        anno::ui_order(5)
    ]],
    uniform bool invert = false
    [[
        anno::description("Invert image"),
        anno::display_name("Invert image"),
        anno::in_group("Bitmap parameters"),
        anno::ui_order(4)
    ]]
)
[[
    anno::display_name("Bitmap texture"),
    anno::description("Allows texturing using image files of various file formats"),
    anno::thumbnail(".thumbs/file_texture.png"),
    anno::in_group("Texturing, high level"),
    anno::ui_order(30),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return invert == false? base::file_texture(
        texture: texture,
        mono_source: mono_source,
        color_offset: color(0.5*brightness-0.5*contrast*brightness),
        color_scale: color(brightness*contrast),
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: float3(scaling.x, scaling.y, 1.0),
                rotation: float3(0.0, 0.0, math::radians(rotation) ),
                translation: float3(translation.x, translation.y, 0.0)
            ),
            coordinate: base::coordinate_source(texture_space: texture_space)
        ),
        wrap_u: clip?tex::wrap_clip:tex::wrap_repeat,
        wrap_v: clip?tex::wrap_clip:tex::wrap_repeat
    ): base::file_texture(
        texture: texture,
        mono_source: mono_source,
        color_offset: color(1.0-0.5*brightness+0.5*contrast*brightness),
        color_scale: color(-brightness*contrast),
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: float3(scaling.x, scaling.y, 1.0),
                rotation: float3(0.0, 0.0, math::radians(rotation) ),
                translation: float3(translation.x, translation.y, 0.0)
            ),
            coordinate: base::coordinate_source(texture_space: texture_space)
        ),
        wrap_u: clip?tex::wrap_clip:tex::wrap_repeat,
        wrap_v: clip?tex::wrap_clip:tex::wrap_repeat
    );
}
export color triplanar_file_texture(
    uniform texture_2d texture_1
    [[
        anno::display_name("Bitmap file"),
        anno::in_group("1st Bitmap parameters"),
        anno::ui_order(0)
    ]],
    float2 scaling_1 = float2(1.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("1st Bitmap parameters"),
        anno::ui_order(1)
    ]],
    float2 translation_1 = float2(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("1st Bitmap parameters"),
        anno::ui_order(2)
    ]],
    float rotation_1 = 0.
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("1st Bitmap parameters"),
        anno::ui_order(3),
        anno::soft_range(0.0,360.0)
    ]],
    uniform texture_2d texture_2 = texture_2d()
    [[
        anno::display_name("Bitmap file"),
        anno::in_group("2nd Bitmap parameters"),
        anno::ui_order(4)
    ]],
    float2 scaling_2 = float2(1.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("2nd Bitmap parameters"),
        anno::enable_if( "tex::texture_isvalid(texture_2)" ),
        anno::ui_order(5)
    ]],
    float2 translation_2 = float2(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("2nd Bitmap parameters"),
        anno::enable_if( "tex::texture_isvalid(texture_2)" ),
        anno::ui_order(6)
    ]],
    float rotation_2 = 0.
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("2nd Bitmap parameters"),
        anno::ui_order(7),
        anno::enable_if( "tex::texture_isvalid(texture_2)" ),
        anno::soft_range(0.0,360.0)
    ]],
    uniform texture_2d texture_3 = texture_2d()
    [[
        anno::display_name("Bitmap file"),
        anno::in_group("3rd Bitmap parameters"),
        anno::ui_order(8)
    ]],
    float2 scaling_3 = float2(1.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("3rd Bitmap parameters"),
        anno::enable_if( "tex::texture_isvalid(texture_3)" ),
        anno::ui_order(9)
    ]],
    float2 translation_3 = float2(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("3rd Bitmap parameters"),
        anno::enable_if( "tex::texture_isvalid(texture_3)" ),
        anno::ui_order(10)
    ]],
    float rotation_3 = 0.
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("3rd Bitmap parameters"),
        anno::ui_order(11),
        anno::enable_if( "tex::texture_isvalid(texture_3)" ),
        anno::soft_range(0.0,360.0)
    ]],
    float blend_range = 0.5
    [[
        anno::description("Defines the size of the transition area. 0 means hard transition, 1 means blending happens very softly."),
        anno::display_name("Blend range"),
        anno::in_group("Common parameters"),
        anno::ui_order(14),
        anno::hard_range(0.0,1.0)
    ]],
    uniform color mean = color(0.0)
    [[
        anno::description("Allows tweaking of the blend function. A value of 0 disables the function."),
        anno::display_name("Mean color"),
        anno::in_group("Common parameters"),
        anno::ui_order(15),
        anno::hard_range(color(0.0),color(1.0))
    ]],
    uniform float3 rotate_origin = float3(0.0)
    [[
        anno::description("Allows manual alignment of the projection with an object"),
        anno::display_name("Rotation of origin"),
        anno::in_group("Placement"),
        anno::ui_order(13),
        anno::soft_range(float3(0.0),float3(360.0))
    ]],
    uniform bool object_space = true
    [[
        anno::description("If off, world space will be used for generating texture coordinates. If on, object space will apply."),
        anno::display_name("Use object space"),
        anno::in_group("Placement"),
        anno::ui_order(12)
    ]]
)
[[
    anno::display_name("Triplanar Bitmap texture"),
    anno::description("Allows texturing using image files of various file formats"),
    anno::thumbnail(".thumbs/file_texture.png"),
    anno::in_group("Texturing, high level"),
    anno::ui_order(30),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT)
]]
{
    state::coordinate_space space = object_space?state::coordinate_object:state::coordinate_world;

    float3 normal = state::transform_normal(state::coordinate_internal, space, state::normal());
    float3 position = state::transform_point(state::coordinate_internal, space, state::position());
    //TODO: pretransform the space?  At least rotating the original space seems desireable and more is not feasible without dedicated ui (gizmo)
    normal = transform_rotate(normal, math::radians(rotate_origin));
    position = transform_rotate(position, math::radians(rotate_origin));

    float3 weights = math::abs(normal);

    //TODO: blendrange through pow or is there something better? pow has the drawback of needing 3 lookups nearly always
    weights /=math::max_value(weights);
    weights = math::pow(weights,1./math::max(blend_range, 0.001));
    //weights = math::saturate(weights-float3(1.-blend_range));

    weights /=float3(weights.x+weights.y+weights.z);


    float2 st1 = normal.x>0?float2(-position.z,position.y):float2(-position.z,-position.y);
    float2 st2 = normal.y>0?float2(-position.z,-position.x):float2(-position.z,position.x);
    float2 st3 = normal.z>0?float2(-position.y,position.x):float2(-position.y,-position.x);

    color c1 = weights.x>0?
        tex::lookup_color(
            texture_1,
            transform_st(math::radians(rotation_1),translation_1,scaling_1,st1))
        :color(0.);
    color c2 = weights.y>0? tex::texture_isvalid(texture_2)?
        tex::lookup_color(
            texture_2,
            transform_st(math::radians(rotation_2),translation_2,scaling_2,st2))
        :tex::lookup_color(
            texture_1,
            transform_st(math::radians(rotation_1),translation_1,scaling_1,st2))
        :color(0.);
    color c3 = weights.z>0? tex::texture_isvalid(texture_3)?
        tex::lookup_color(
            texture_3,
            transform_st(math::radians(rotation_3),translation_3,scaling_3,st3))
        :tex::lookup_color(
            texture_1,
            transform_st(math::radians(rotation_1),translation_1,scaling_1,st3))
        :color(0.);
    return mean == color(0.0)?
                c1*weights.x + c2*weights.y+ c3*weights.z:
                biased_color_blend(weights.x,c1,weights.y,c2,weights.z,c3,mean);
}

export texture_return perlin_noise_texture(
    color color1 = color(1.)
    [[
        anno::display_name("Color 1"),
        anno::in_group("Noise parameters"),
        anno::ui_order(1)
    ]],
    color color2 = color(0.)
    [[
        anno::display_name("Color 2"),
        anno::in_group("Noise parameters"),
        anno::ui_order(2)
    ]],
    uniform bool object_space = true
    [[
        anno::description("If off, UV space will be used. If on, 3D texturing in object space will apply. For applications that do not support object space, world space will be used."),
        anno::display_name("Use object space"),
        anno::in_group("Placement"),
        anno::ui_order(7)
    ]],
    uniform int noise_levels = 3
    [[
        anno::description("Higher amounts will add detail to the noise"),
        anno::display_name("Levels"),
        anno::hard_range(1,6),
        anno::in_group("Noise parameters"),
        anno::ui_order(3)
    ]],
    uniform bool absolute_noise = false
    [[
        anno::display_name("Billowing appearance"),
        anno::in_group("Noise parameters"),
        anno::ui_order(4)
    ]],
    uniform float noise_threshold_high = 1.
    [[
        anno::hard_range(0.0,1.),
        anno::description("Lowering this value will create bigger areas uniformly colored with Color 1"),
        anno::display_name("Upper threshold"),
        anno::in_group("Noise parameters"),
        anno::ui_order(6)
    ]],
    uniform float noise_threshold_low = 0.
    [[
        anno::hard_range(0.0,1.),
        anno::description("Increasing this value will create bigger areas uniformly colored with Color 2"),
        anno::display_name("Lower threshold"),
        anno::in_group("Noise parameters"),
        anno::ui_order(5)
    ]],
    float3 scaling = float3(10.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        anno::ui_order(11)
    ]],
    float3 translation = float3(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        anno::ui_order(10)
    ]],
    float3 rotation = float3(0.)
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        anno::ui_order(9)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Only applies if \"Use object space\" is off. Selects a specific UV space."),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        anno::ui_order(8)
    ]]
)
[[
    anno::display_name("Perlin noise texture"),
    anno::description("Enable texturing with a random noise pattern"),
    anno::thumbnail(".thumbs/perlin_noise_texture.png"),
    anno::in_group("Texturing, high level"),
    anno::ui_order(34),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::perlin_noise_texture(
        color1: color1,
        color2: color2,
        noise_levels: noise_levels,
        absolute_noise: absolute_noise,
        noise_threshold_high: noise_threshold_high,
        noise_threshold_low: noise_threshold_low,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: object_space?scaling*state::meters_per_scene_unit() :scaling,

                translation: translation,
                rotation: math::radians(rotation)
            ),
            coordinate: object_space?
                base::coordinate_source(coordinate_system: base::texture_coordinate_object):
                base::coordinate_source(texture_space: texture_space)
        )
    );
}

export float3 perlin_noise_bump_texture(
    uniform float factor = 1.
    [[
        anno::display_name("Bump strength"),
        anno::in_group("Noise parameters"),
        anno::ui_order(0),
        anno::soft_range(0.0,5.0)
    ]],
    float3 scaling = float3(10.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        anno::ui_order(9)
    ]],
    uniform int noise_levels = 1
    [[
        anno::description("Higher amounts will add detail to the noise"),
        anno::display_name("Levels"),
        anno::hard_range(1,6),
        anno::in_group("Noise parameters"),
        anno::ui_order(1)
    ]],
    uniform bool object_space = true
    [[
        anno::description("If off, UV space will be used. If on, 3D texturing in object space will apply. For applications that do not support object space, world space will be used."),
        anno::display_name("Use object space"),
        anno::in_group("Placement"),
        anno::ui_order(5)
    ]],
    uniform bool absolute_noise = false
    [[
        anno::display_name("Billowing appearance"),
        anno::in_group("Noise parameters"),
        anno::ui_order(2)
    ]],
    uniform float noise_threshold_high = 1.
    [[
        anno::hard_range(0.0,1.),
        anno::description("Lowering this value will create bigger areas uniformly colored with Color 1"),
        anno::display_name("Upper threshold"),
        anno::in_group("Noise parameters"),
        anno::ui_order(4)
    ]],
    uniform float noise_threshold_low = 0.
    [[
        anno::hard_range(0.0,1.),
        anno::description("Increasing this value will create bigger areas uniformly colored with Color 2"),
        anno::display_name("Lower threshold"),
        anno::in_group("Noise parameters"),
        anno::ui_order(3)
    ]],
    float3 translation = float3(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        anno::ui_order(8)
    ]],
    float3 rotation = float3(0.)
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        anno::ui_order(7)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Only applies if \"Use object space\" is off. Selects a specific UV space."),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        anno::ui_order(6)
    ]]
)
[[
    anno::display_name("Perlin noise texture - bump mapping"),
    anno::description("Enable bump-map texturing with a random noise pattern"),
    anno::thumbnail(".thumbs/perlin_noise_bump_texture.png"),
    anno::in_group("Texturing, high level"),
    anno::ui_order(35),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::perlin_noise_bump_texture(
        factor: factor,
        noise_levels: noise_levels,
        absolute_noise: absolute_noise,
        noise_threshold_high: noise_threshold_high,
        noise_threshold_low: noise_threshold_low,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: scaling,
                translation: translation,
                rotation: math::radians(rotation)
            ),
            coordinate: object_space?
                base::coordinate_source(coordinate_system: base::texture_coordinate_object):
                base::coordinate_source(texture_space: texture_space)
        )
    );
}

export texture_return worley_noise_texture(
    color color1 = color(1.)
    [[
        anno::display_name("Color 1"),
        anno::in_group("Noise parameters"),
        anno::ui_order(0)
    ]],
    color color2 = color(0.)
    [[
        anno::display_name("Color 2"),
        anno::in_group("Noise parameters"),
        anno::ui_order(1)
    ]],
    uniform bool object_space = true
    [[
        anno::description("If off, UV space will be used. If on, 3D texturing in object space will apply. For applications that do not support object space, world space will be used."),
        anno::display_name("Use object space") ,
        anno::in_group("Placement"),
        anno::ui_order(6)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Only applies if \"Use object space\" is off. Selects a specific UV space."),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        anno::ui_order(7)
    ]],
    uniform cell_type mode = simple_cells
    [[
        anno::display_name("Cell type") ,
        anno::description("Cell pattern type"),
        anno::in_group("Noise parameters"),
        anno::ui_order(2)
    ]],
    uniform cell_base metric = circular_cells
    [[
        anno::display_name("Cell shape") ,
        anno::description("The shape of the cell form"),
        anno::in_group("Noise parameters"),
        anno::ui_order(3)
    ]],
    uniform float noise_threshold_high = 1.
    [[
        anno::hard_range(0.0,1.),
        anno::description("Lowering this value will create bigger areas uniformly colored with Color 1"),
        anno::display_name("Upper threshold"),
        anno::in_group("Noise parameters"),
        anno::ui_order(5)
    ]],
    uniform float noise_threshold_low = 0.
    [[
        anno::hard_range(0.0,1.),
        anno::description("Increasing this value will create bigger areas uniformly colored with Color 2"),
        anno::display_name("Lower threshold"),
        anno::in_group("Noise parameters"),
        anno::ui_order(4)
    ]],
    float3 scaling = float3(10.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        anno::ui_order(10)
    ]],
    float3 translation = float3(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        anno::ui_order(9)
    ]],
    float3 rotation = float3(0.)
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        anno::ui_order(8)
    ]])
[[
    anno::display_name("Cellular noise texture"),
    anno::description("Allow texturing with a cell forming pattern"),
    anno::thumbnail(".thumbs/worley_noise_texture.png"),
    anno::in_group("Texturing, high level"),
    anno::ui_order(36),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::worley_noise_texture(
        color1: color1,
        color2: color2,
        mode: mode==crystal_cells?2:mode==bordered_cells?3:0,
        metric: metric,
        noise_threshold_high: noise_threshold_high,
        noise_threshold_low: noise_threshold_low,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: object_space?scaling*state::meters_per_scene_unit() :scaling,
                translation: translation,
                rotation: math::radians(rotation)
            ),
            coordinate: object_space?
                base::coordinate_source(coordinate_system: base::texture_coordinate_object):
                base::coordinate_source(texture_space: texture_space)
        )
    );
}

export float3 worley_noise_bump_texture(
    uniform float factor = 1.
    [[
        anno::display_name("Bump strength"),
        anno::in_group("Noise parameters"),
        anno::ui_order(0),
        anno::soft_range(0.0,1.0)
    ]],
    uniform cell_base metric = circular_cells
    [[
        anno::display_name("Cell shape") ,
        anno::description("The shape of the cell form"),
        anno::in_group("Noise parameters"),
        anno::ui_order(1)
    ]],
    uniform bool object_space = true
    [[
        anno::description("If off, UV space will be used. If on, 3D texturing in object space will apply. For applications that do not support object space, world space will be used."),
        anno::display_name("Use object space"),
        anno::in_group("Placement"),
        anno::ui_order(4)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Only applies if \"Use object space\" is off. Selects a specific UV space."),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        anno::ui_order(5)
    ]],
    uniform float noise_threshold_high = 1.
    [[
        anno::hard_range(0.0,1.),
        anno::description("Lowering this value will create bigger areas uniformly colored with Color 1"),
        anno::display_name("Upper threshold"),
        anno::in_group("Noise parameters"),
        anno::ui_order(3)
    ]],
    uniform float noise_threshold_low = 0.
    [[
        anno::hard_range(0.0,1.),
        anno::description("Increasing this value will create bigger areas uniformly colored with Color 2"),
        anno::display_name("Lower threshold"),
        anno::in_group("Noise parameters"),
        anno::ui_order(2)
    ]],
    float3 scaling = float3(10.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        anno::ui_order(8)
    ]],
    float3 translation = float3(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        anno::ui_order(7)
    ]],
    float3 rotation = float3(0.)
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        anno::ui_order(6)
    ]])
[[
    anno::display_name("Cellular noise texture - bump mapping"),
    anno::description("Allow texturing with a cell forming pattern"),
    anno::thumbnail(".thumbs/worley_noise_bump_texture.png"),
    anno::in_group("Texturing, high level"),
    anno::ui_order(37),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::worley_noise_bump_texture(
        factor: factor,
        metric: metric,
        noise_threshold_high: noise_threshold_high,
        noise_threshold_low: noise_threshold_low,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: object_space?scaling*state::meters_per_scene_unit() :scaling,
                translation: translation,
                rotation: math::radians(rotation)
            ),
            coordinate: object_space?
                base::coordinate_source(coordinate_system: base::texture_coordinate_object):
                base::coordinate_source(texture_space: texture_space)
        )
    );
}

export texture_return flow_noise_texture(
    color color1 = color(1.)
    [[
        anno::display_name("Color 1"),
        anno::in_group("Noise parameters"),
        anno::ui_order(0)
    ]],
    color color2 = color(0.)
    [[
        anno::display_name("Color 2"),
        anno::in_group("Noise parameters"),
        anno::ui_order(1)
    ]],
    uniform bool object_space = false
    [[
        anno::description("If off, UV space will be used. If on, 3D texturing in object space will apply. For applications that do not support object space, world space will be used."),
        anno::display_name("Use object space"),
        anno::in_group("Placement"),
        anno::ui_order(10)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Only applies if \"Use object space\" is off. Selects a specific UV space."),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        anno::ui_order(11)
    ]],
    uniform int noise_levels = 3
    [[
        anno::description("Higher amounts will add detail to the noise"),
        anno::display_name("Levels"),
        anno::hard_range(1,6),
        anno::in_group("Noise parameters"),
        anno::ui_order(3)

    ]],
    uniform bool absolute_noise = false
    [[
        anno::display_name("Billowing appearance"),
        anno::in_group("Noise parameters"),
        anno::ui_order(4)

    ]],
    uniform float phase = 0.0
    [[
        anno::display_name("Phase offset"),
        anno::description("Controls the third dimension of the function"),
        anno::in_group("Noise parameters"),
        anno::ui_order(5),
        anno::soft_range(0.0,1.0)
    ]],
    uniform float level_gain = 0.5
    [[
        anno::display_name("Level intensity gain"),
        anno::description("If multiple levels are used, this parameter specifies a weighting factor for subsequent levels"),
        anno::in_group("Noise parameters"),
        anno::ui_order(6),
        anno::soft_range(0.0,1.0)
    ]],
    uniform float level_scale = 2.0
    [[
        anno::display_name("Level scaling"),
        anno::description("If multiple levels are used, this parameter specifies a global scaling factor for subsequent levels"),
        anno::in_group("Noise parameters"),
        anno::ui_order(7),
        anno::soft_range(0.0,4.0)
    ]],
    uniform float level_progressive_u_scale = 1.
    [[
        anno::display_name("Progressive u scale"),
        anno::description("If multiple levels are used, this parameter specifies an additional scaling factor in the \"u\" direction"),
        anno::in_group("Noise parameters"),
        anno::ui_order(8),
        anno::soft_range(0.0,1.0)
    ]],
    uniform float level_progressive_v_motion = 0.
    [[
        anno::display_name("Progressive v offset"),
        anno::description("If multiple levels are used, this parameter specifies an offset for subsequent levels in the \"v\" direction"),
        anno::in_group("Noise parameters"),
        anno::ui_order(9),
        anno::soft_range(0.0,1.0)
    ]],
    float3 scaling = float3(10.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        anno::ui_order(15)
    ]],
    float3 translation = float3(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        anno::ui_order(14)
    ]],
    float3 rotation = float3(0.)
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        anno::ui_order(13)
    ]])
[[
    anno::display_name("Flow noise texture"),
    anno::description("Allow texturing with a 2D noise pattern suitable for waves"),
    anno::thumbnail(".thumbs/flow_noise_texture.png"),
    anno::in_group("Texturing, high level"),
    anno::ui_order(38),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::flow_noise_texture(
        color1: color1,
        color2: color2,
        levels: noise_levels,
        phase: phase,
        level_gain: level_gain,
        level_scale: level_scale,
        level_progressive_u_scale: level_progressive_u_scale,
        level_progressive_v_motion: level_progressive_v_motion,
        absolute_noise: absolute_noise,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: object_space?scaling*state::meters_per_scene_unit() :scaling,
                translation: translation,
                rotation: math::radians(rotation)
            ),
            coordinate: object_space?
                base::coordinate_source(coordinate_system: base::texture_coordinate_object):
                base::coordinate_source(texture_space: texture_space)
        )
    );
}

export float3 flow_noise_bump_texture(
    uniform float factor = 1.
    [[
        anno::display_name("Bump strength"),
        anno::in_group("Noise parameters"),
        anno::ui_order(0),
        anno::soft_range(0.0,1.0)
    ]],
    float3 scaling = float3(10.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        anno::ui_order(12)
    ]],
    uniform int noise_levels = 1
    [[
        anno::description("Higher amounts will add detail to the noise"),
        anno::display_name("Levels"),
        anno::hard_range(1,6),
        anno::in_group("Noise parameters"),
        anno::ui_order(1)
    ]],
    uniform bool object_space = false
    [[
        anno::description("If off, UV space will be used. If on, 3D texturing in object space will apply. For applications that do not support object space, world space will be used."),
        anno::display_name("Use object space"),
        anno::in_group("Placement"),
        anno::ui_order(8)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Only applies if \"Use object space\" is off. Selects a specific UV space."),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        anno::ui_order(9)
    ]],
    uniform bool absolute_noise = false
    [[
        anno::display_name("Billowing appearance"),
        anno::in_group("Noise parameters"),
        anno::ui_order(2)
    ]],
    uniform float phase = 0.0
    [[
        anno::display_name("Phase offset"),
        anno::description("Controls the 3rd dimension of the function"),
        anno::in_group("Noise parameters"),
        anno::ui_order(3),
        anno::soft_range(0.0,1.0)
    ]],
    uniform float level_gain = 0.5
    [[
        anno::display_name("Level intensity gain"),
        anno::description("If multiple levels are used, this parameter specifies a weighting factor for subsequent levels"),
        anno::in_group("Noise parameters"),
        anno::ui_order(4),
        anno::soft_range(0.0,1.0)
    ]],
    uniform float level_scale = 2.0
    [[
        anno::display_name("Level scaling"),
        anno::description("If multiple levels are used, this parameter specifies a global scaling factor for subsequent levels"),
        anno::in_group("Noise parameters"),
        anno::ui_order(5),
        anno::soft_range(0.0,4.0)
    ]],
    uniform float level_progressive_u_scale = 1.
    [[
        anno::display_name("Progressive u scale"),
        anno::description("If multiple levels are used, this parameter specifies an additional scaling factor in the \"u\" direction"),
        anno::in_group("Noise parameters"),
        anno::ui_order(6),
        anno::soft_range(0.0,1.0)
    ]],
    uniform float level_progressive_v_motion = 0.
    [[
        anno::display_name("Progressive v offset"),
        anno::description("If multiple levels are used, this parameter specifies an offset for subsequent levels in the \"v\" direction"),
        anno::in_group("Noise parameters"),
        anno::ui_order(7),
        anno::soft_range(0.0,1.0)
    ]],
    float3 translation = float3(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        anno::ui_order(11)
    ]],
    float3 rotation = float3(0.)
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        anno::ui_order(10)
    ]])
[[
    anno::display_name("Flow noise texture - bump mapping"),
    anno::description("Allow texturing with a 2D noise pattern suitable for waves"),
    anno::thumbnail(".thumbs/flow_noise_bump_texture.png"),
    anno::in_group("Texturing, high level"),
    anno::ui_order(39),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::flow_noise_bump_texture(
        factor: factor,
        levels: noise_levels,
        phase: phase,
        level_gain: level_gain,
        level_scale: level_scale,
        level_progressive_u_scale: level_progressive_u_scale,
        level_progressive_v_motion: level_progressive_v_motion,
        absolute_noise: absolute_noise,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: object_space?scaling*state::meters_per_scene_unit() :scaling,
                translation: translation,
                rotation: math::radians(rotation)
            ),
            coordinate: object_space?
                base::coordinate_source(coordinate_system: base::texture_coordinate_object):
                base::coordinate_source(texture_space: texture_space)
        )
    );
}

export texture_return checker_texture(
    color color1 = color(1.)
    [[
        anno::display_name("Color 1"),
        anno::in_group("Checker parameters"),
        anno::ui_order(0)
    ]],
    color color2 = color(0.)
    [[
        anno::display_name("Color 2"),
        anno::in_group("Checker parameters"),
        anno::ui_order(1)
    ]],
    float3 scaling = float3(10.)
     [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        anno::ui_order(7)
    ]],
    float3 translation = float3(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        anno::ui_order(6)
    ]],
    uniform bool object_space = false
    [[
        anno::description("If off, UV space will be used. If on, 3D texturing in object space will apply. For applications that do not support object space, world space will be used."),
        anno::display_name("Use object space"),
        anno::in_group("Placement"),
        anno::ui_order(3)
    ]],
    uniform float blur = 0
    [[
        anno::hard_range(0.0,1.0),
        anno::display_name("Blur"),
        anno::in_group("Checker parameters"),
        anno::ui_order(2)
    ]],
    float3 rotation = float3(0.)
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        anno::ui_order(5)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Only applies if \"Use object space\" is off. Selects a specific UV space."),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        anno::ui_order(4)
    ]]
)
[[
    anno::display_name("3D checker texture"),
    anno::description("Allows texturing a checkerboard pattern"),
    anno::thumbnail(".thumbs/checker_texture.png"),
    anno::in_group("Texturing, high level"),
    anno::ui_order(40),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::checker_texture(
        color1: color1,
        color2: color2,
        blur: blur/4.,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: object_space?scaling*state::meters_per_scene_unit() :scaling,
                translation: translation,
                rotation: math::radians(rotation)
            ),
            coordinate: object_space?
                base::coordinate_source(coordinate_system: base::texture_coordinate_object):
                base::coordinate_source(texture_space: texture_space)
        )
    );
}

export float3 checker_bump_texture(
    uniform float factor = 1.
    [[
        anno::display_name("Bump strength"),
        anno::in_group("Checker parameters"),
        anno::ui_order(0),
        anno::soft_range(0.0,1.0)
    ]],
    uniform float blur = 0
    [[
        anno::hard_range(0.0,1.0),
        anno::display_name("Blur"),
        anno::in_group("Checker parameters"),
        anno::ui_order(1)
    ]],
    uniform bool object_space = false
    [[
        anno::description("If off, UV space will be used. If on, 3D texturing in object space will apply. For applications that do not support object space, world space will be used."),
        anno::display_name("Use object space"),
        anno::in_group("Placement"),
        anno::ui_order(2)
    ]],
    float3 scaling = float3(10.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        anno::ui_order(6)
    ]],
    float3 translation = float3(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        anno::ui_order(5)
    ]],
    float3 rotation = float3(0.)
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        anno::ui_order(4)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Only applies if \"Use object space\" is off. Selects a specific UV space."),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        anno::ui_order(3)
    ]]
)
[[
    anno::display_name("3D checker texture - bump mapping"),
    anno::description("Allows texturing a checkerboard pattern"),
    anno::thumbnail(".thumbs/checker_bump_texture.png"),
    anno::in_group("Texturing, high level"),
    anno::ui_order(41),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::checker_bump_texture(
        factor: factor,
        blur: blur/4.,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: object_space?scaling*state::meters_per_scene_unit() :scaling,
                translation: translation,
                rotation: math::radians(rotation)
            ),
            coordinate: object_space?
                base::coordinate_source(coordinate_system: base::texture_coordinate_object):
                base::coordinate_source(texture_space: texture_space)
        )
    );
}

export float3 file_bump_texture(
    uniform texture_2d texture
    [[
        anno::display_name("Bitmap file"),
        anno::in_group("Bitmap parameters"),
        anno::usage("normal"),
        anno::ui_order(1)
    ]],
    uniform mono_mode bump_source = mono_average
    [[
        anno::display_name("Bump mode"),
        anno::description("Defines how the texture is evaluated to create the bumps"),
        anno::in_group("Bitmap parameters"),
        anno::ui_order(2)
    ]],
    float2 scaling = float2(1.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        anno::ui_order(8)
    ]],
    float2 translation = float2(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        anno::ui_order(7)
    ]],
    float rotation = 0.
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        anno::ui_order(6),
        anno::soft_range(0.0,360.0)
    ]],
    uniform bool clip = false
    [[
        anno::description("If set to true, texture will not repeat. Outside of the texture the surface will be flat"),
        anno::display_name("Clip"),
        anno::in_group("Placement"),
        anno::ui_order(5)

    ]],
    uniform float factor = 1
    [[
        anno::display_name("Bump strength"),
        anno::in_group("Bitmap parameters"),
        anno::ui_order(3),
        anno::soft_range(0.0,1.0)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Selects a specific UV space"),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        anno::ui_order(4)
    ]]
)
[[
    anno::display_name("Bitmap texture, bump"),
    anno::description("Allows texturing using image files of various file formats"),
    anno::thumbnail(".thumbs/file_bump_texture.png"),
    anno::in_group("Texturing, high level"),
    anno::ui_order(31),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::file_bump_texture(
        texture: texture,
        bump_source: bump_source,
        factor: factor,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: float3(scaling.x, scaling.y, 1.0),
                rotation: float3(0.0, 0.0, math::radians(rotation) ),
                translation: float3(translation.x, translation.y, 0.0)
            ),
            coordinate: base::coordinate_source(texture_space: texture_space)
        ),
        wrap_u: clip?tex::wrap_clamp:tex::wrap_repeat,
        wrap_v: clip?tex::wrap_clamp:tex::wrap_repeat,
        clip: clip
    );
}

export float3 normalmap_texture(
    uniform texture_2d texture
    [[
        anno::display_name("Normalmap file"),
        anno::in_group("Normalmap parameters"),
        anno::usage("normal"),
        anno::ui_order(1)
    ]],
    float2 scaling = float2(1.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        anno::ui_order(8)
    ]],
    float2 translation = float2(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        anno::ui_order(7)
    ]],
    float rotation = 0.
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        anno::ui_order(6),
        anno::soft_range(0.0,360.0)
    ]],
    uniform bool clip = false
    [[
        anno::description("If set to true, texture will not repeat. Outside of the texture the surface will be flat."),
        anno::display_name("Clip"),
        anno::in_group("Placement"),
        anno::ui_order(4)

    ]],
    uniform float factor = 1
    [[
        anno::display_name("Strength"),
        anno::in_group("Normal map parameters"),
        anno::ui_order(2),
        anno::soft_range(0.0,1.0)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Selects a specific UV space"),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        anno::ui_order(3)
    ]],
    uniform bool flip = false
    [[
        anno::description("Flip handedness of the tangent space"),
        anno::display_name("Flip V"),
        anno::in_group("Placement"),
        anno::ui_order(6)
    ]]
)
[[
    anno::display_name("Normal map texture"),
    anno::description("Allows the use of tangent space normal maps"),
    anno::thumbnail(".thumbs/normalmap_texture.png"),
    anno::in_group("Texturing, high level"),
    anno::ui_order(32),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::tangent_space_normal_texture(
        texture: texture,
        factor: factor,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: float3(scaling.x, scaling.y, 1.0),
                rotation: float3(0.0, 0.0, math::radians(rotation) ),
                translation: float3(translation.x, translation.y, 0.0)
            ),
            coordinate: base::coordinate_source(texture_space: texture_space)
        ),
        wrap_u: clip?tex::wrap_clamp:tex::wrap_repeat,
        wrap_v: clip?tex::wrap_clamp:tex::wrap_repeat,
        flip_tangent_v: flip,
        clip: clip
    );
}
export float3 triplanar_normalmap_texture(
    uniform texture_2d texture_1
    [[
        anno::usage("normal"),
        anno::display_name("Bitmap file"),
        anno::in_group("1st Bitmap parameters"),
        anno::ui_order(0)
    ]],
    float2 scaling_1 = float2(1.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("1st Bitmap parameters"),
        anno::ui_order(1)
    ]],
    float2 translation_1 = float2(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("1st Bitmap parameters"),
        anno::ui_order(2)
    ]],
    float rotation_1 = 0.
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("1st Bitmap parameters"),
        anno::ui_order(3),
        anno::soft_range(0.0,360.0)
    ]],
    uniform bool flip_1 = false
    [[
        anno::description("Flip handedness of the tangent space"),
        anno::display_name("Flip V"),
        anno::in_group("1st Bitmap parameters"),
        anno::ui_order(4)
    ]],
    uniform texture_2d texture_2 = texture_2d()
    [[
        anno::display_name("Bitmap file"),
        anno::in_group("2nd Bitmap parameters"),
        anno::usage("normal"),
        anno::ui_order(4)
    ]],
    float2 scaling_2 = float2(1.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("2nd Bitmap parameters"),
        anno::enable_if( "tex::texture_isvalid(texture_2)" ),
        anno::ui_order(5)
    ]],
    float2 translation_2 = float2(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("2nd Bitmap parameters"),
        anno::enable_if( "tex::texture_isvalid(texture_2)" ),
        anno::ui_order(6)
    ]],
    float rotation_2 = 0.
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("2nd Bitmap parameters"),
        anno::ui_order(7),
        anno::enable_if( "tex::texture_isvalid(texture_2)" ),
        anno::soft_range(0.0,360.0)
    ]],
    uniform bool flip_2 = false
    [[
        anno::description("Flip handedness of the tangent space"),
        anno::display_name("Flip V"),
        anno::in_group("2nd Bitmap parameters"),
        anno::ui_order(8)
    ]],
    uniform texture_2d texture_3 = texture_2d()
    [[
        anno::display_name("Bitmap file"),
        anno::in_group("3rd Bitmap parameters"),
        anno::ui_order(8),
        anno::usage("normal")
    ]],
    float2 scaling_3 = float2(1.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("3rd Bitmap parameters"),
        anno::enable_if( "tex::texture_isvalid(texture_3)" ),
        anno::ui_order(9)
    ]],
    float2 translation_3 = float2(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("3rd Bitmap parameters"),
        anno::enable_if( "tex::texture_isvalid(texture_3)" ),
        anno::ui_order(10)
    ]],
    float rotation_3 = 0.
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("3rd Bitmap parameters"),
        anno::ui_order(11),
        anno::enable_if( "tex::texture_isvalid(texture_3)" ),
        anno::soft_range(0.0,360.0)
    ]],
    uniform bool flip_3 = false
    [[
        anno::description("Flip handedness of the tangent space"),
        anno::display_name("Flip V"),
        anno::in_group("3rd Bitmap parameters"),
        anno::ui_order(12)
    ]],
    float blend_range = 0.5
    [[
        anno::description("Defines the size of the transition area. 0 means hard transition, 1 means blending happens very softly."),
        anno::display_name("Blend range"),
        anno::in_group("Common parameters"),
        anno::ui_order(13),
        anno::hard_range(0.0,1.0)
    ]],
    float strength = 1.0
    [[
        anno::description("Overall strength of the normalmap"),
        anno::display_name("Strength"),
        anno::in_group("Common parameters"),
        anno::ui_order(14),
        anno::soft_range(0.0,10.0)
    ]],
    uniform float3 rotate_origin = float3(0.0)
    [[
        anno::description("Allows manual alignment of the projection with an object"),
        anno::display_name("Rotation of origin"),
        anno::in_group("Placement"),
        anno::ui_order(16),
        anno::soft_range(float3(0.0),float3(360.0))
    ]],
    uniform bool object_space = true
    [[
        anno::description("If off, world space will be used for generating texture coordinates. If on, object space will apply."),
        anno::display_name("Use object space"),
        anno::in_group("Placement"),
        anno::ui_order(15)
    ]]
)
[[
    anno::display_name("Triplanar Normalmap texture"),
    anno::description("Allows texturing using image files of various file formats"),
    anno::thumbnail(".thumbs/file_texture.png"),
    anno::in_group("Texturing, high level"),
    anno::ui_order(32),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT)
]]
{
    state::coordinate_space space = object_space?state::coordinate_object:state::coordinate_world;

    float3 normal = state::transform_normal(state::coordinate_internal, space, state::normal());
    float3 position_original = state::transform_point(state::coordinate_internal, space, state::position());
    float3 rotation_origin_rad = math::radians(rotate_origin);
    normal = transform_rotate(normal, rotation_origin_rad);
    float3 position = transform_rotate(position_original, rotation_origin_rad);
    float3 ty =
        math::normalize(
            transform_rotate_inv(state::transform_vector(space,state::coordinate_internal,float3(0.,-1.,0.)),rotation_origin_rad));
    float3 tz =
        math::normalize(
            transform_rotate_inv(state::transform_vector(space,state::coordinate_internal,float3(0.,0.,-1.)),rotation_origin_rad));

    float3 weights = math::abs(normal);

    //TODO: blendrange through pow or is there something better? Pow means relatively little area where only 1 texture is looked up
    weights /=math::max_value(weights);
    weights = math::pow(weights,1./math::max(blend_range, 0.001));



    float2 st1 = normal.x>0.0?float2(-position.z,position.y):float2(-position.z,-position.y);
    float3 ts = math::normalize(math::cross(state::normal(),tz));
    float3 tt1 = math::normalize(math::cross(state::normal(),ts));
    
    float2 st2 = normal.y>0?float2(-position.z,-position.x):float2(-position.z,position.x);

    float2 st3 = normal.z>0?float2(-position.y,position.x):float2(-position.y,-position.x);
    float3 ts3 = math::normalize(math::cross(state::normal(),ty));
    float3 tt3 = math::normalize(math::cross(state::normal(),ts3));

    tt3 = ( (tex::texture_isvalid(texture_3) && flip_3) || flip_1)? -tt3: tt3;
    float3 tt2 = ( (tex::texture_isvalid(texture_2) && flip_2) || flip_1)? -tt1: tt1;
    tt1 = flip_1? -tt1: tt1;
    
    float3 n1 = weights.x>0 && tex::texture_isvalid(texture_1)?
        (tex::lookup_float3(
            texture_1,
            transform_st(math::radians(rotation_1),translation_1,scaling_1,st1))- float3(0.5)) * (2.0 * strength)
        :float3(0.,0.,1.);
    n1 = math::normalize(
        ts * n1.x +
        tt1 * n1.y +
        state::normal() * (n1.z + (1.0 - strength)));

    float3 n2 = weights.y>0? tex::texture_isvalid(texture_2)?
        (tex::lookup_float3(
            texture_2,
            transform_st(math::radians(rotation_2),translation_2,scaling_2,st2))- float3(0.5)) * (2.0 * strength)
        :tex::texture_isvalid(texture_1)?(tex::lookup_float3(
            texture_1,
            transform_st(math::radians(rotation_1),translation_1,scaling_1,st2))- float3(0.5)) * (2.0 * strength)
        :float3(0.,0.,1.):float3(0.,0.,1.);
    n2 = math::normalize(
        ts * n2.x +
        tt2 * n2.y +
        state::normal() * (n2.z + (1.0 - strength)));

    float3 n3 = weights.z>0? tex::texture_isvalid(texture_3)?
        (tex::lookup_float3(
            texture_3,
            transform_st(math::radians(rotation_3),translation_3,scaling_3,st3))- float3(0.5)) * (2.0 * strength)
        :tex::texture_isvalid(texture_1)?(tex::lookup_float3(
            texture_1,
            transform_st(math::radians(rotation_1),translation_1,scaling_1,st3))- float3(0.5)) * (2.0 * strength)
        :float3(0.,0.,1.):float3(0.,0.,1.);
    n3 = math::normalize(
        ts3 * n3.x +
        tt3 * n3.y +
        state::normal() * (n3.z + (1.0 - strength)));

    return  blend_3_normals(n1,weights.x,n2,weights.y,n3,weights.z);
}

//endgroup

//material section-----------------------------------------------------------------------------------------------

//group Simple materials

export material diffuse(
    color diffuse_color = color(.8)
    [[
        anno::display_name("Color"),
        anno::description("The color of the material")
    ]],
    float roughness = 0.0
    [[
        anno::display_name("Diffuse roughness"),
        anno::hard_range(0.0,1.),
        anno::description("Higher roughness values lead a powdery appearance")
    ]],
    float3 normal = state::normal()
    [[
        anno::display_name("Bumps"),
        anno::description("Attach bump or normal maps here")
    ]]
)
[[
    anno::display_name("Simple diffuse"),
    anno::description("A basic diffuse material"),
    anno::thumbnail(".thumbs/diffuse.png"),
    anno::in_group("Materials"),
    anno::ui_order(0),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(simple_material),
    anno::key_words(string[]("generic"))
]]
 =  material(
    thin_walled: true,
    surface: material_surface(
        scattering: df::weighted_layer(
            weight: 1.,
            normal: normal,
            layer: df::diffuse_reflection_bsdf(
                    roughness: roughness,
                    tint: diffuse_color
            )
        )
    )
);

export material scratched_metal_v2(
    color metal_color = color(.9)
    [[
        anno::display_name("Color"),
        anno::description("The color of the metal")
    ]],
    float roughness = 0.2
    [[
        anno::display_name("Roughness"),
        anno::hard_range(0.0,1.),
        anno::description("Higher roughness values lead to bigger highlights and blurry reflections")
    ]],
    float glossy_weight = .9
    [[
        anno::display_name("Reflection weight"),
        anno::hard_range(0.0,1.),
        anno::description("Intensity of highlights and glossy reflections and highlights")
    ]],
    float anisotropy = 0.0
    [[
        anno::display_name("Anisotropy"),
        anno::hard_range(0.0,1.),
        anno::description("Higher values will stretch the highlight")
    ]],
    float anisotropy_rotation = 0.0
    [[
        anno::display_name("Anisotropy rotation"),
        anno::hard_range(0.0,1.),
        anno::description("Changes the orientation of the anisotropy. A value of 1 will rotate the orientation 360 degrees.")
    ]],
    float3 normal = state::normal()
    [[
        anno::display_name("Bumps"),
        anno::description("Attach bump or normal maps here")
    ]]
)
[[
    anno::display_name("Metal"),
    anno::description("A metallic material with stretched reflections"),
    anno::thumbnail(".thumbs/scratched_metal.png"),
    anno::in_group("Materials"),
    anno::ui_order(1),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(simple_material),
    anno::key_words(string[]("generic","metal"))
]]
 = let{
    base::anisotropy_return anisotropy_values = base::anisotropy_conversion(
        roughness: roughness*roughness,
        anisotropy: anisotropy,
        anisotropy_rotation: anisotropy_rotation
    );
    bsdf glossy_bsdf = df::microfacet_ggx_smith_bsdf(
        mode: df::scatter_reflect,
        tint: metal_color,
        roughness_u: anisotropy_values.roughness_u,
        roughness_v: anisotropy_values.roughness_v,
        tangent_u: anisotropy_values.tangent_u
    );
} in material(
    thin_walled: true,
    surface: material_surface(
        scattering: df::weighted_layer(
            weight: 1.,
            normal: normal,
            layer: df::weighted_layer(
                weight: glossy_weight,
                layer: glossy_bsdf,
                base: df::diffuse_reflection_bsdf(
                    roughness: 0.0,
                    tint: metal_color
                ),
                normal: normal
            )
        )
    )
);

export material scratched_plastic_v2(
    color diffuse_color = color(.5)
    [[
        anno::display_name("Color"),
        anno::description("The color of the material"),
        anno::ui_order(1)
    ]],
    float roughness = 0.2
    [[
        anno::display_name("Roughness"),
        anno::hard_range(0.0,1.),
        anno::description("Higher roughness values lead to bigger highlights and blurry reflections"),
        anno::ui_order(2)
    ]],
    float anisotropy = 0.0
    [[
        anno::display_name("Anisotropy"),
        anno::hard_range(0.0,1.),
        anno::description("Higher values will stretch the highlight"),
        anno::ui_order(4)
    ]],
    float anisotropy_rotation = 0.0
    [[
        anno::display_name("Anisotropy rotation"),
        anno::hard_range(0.0,1.),
        anno::description("Changes the orientation of the anisotropy. A value of 1 will rotate the orientation 360 degrees."),
        anno::ui_order(5)
    ]],
    uniform float ior = 1.4
    [[
        anno::display_name("IOR"),
        anno::soft_range(1.0,4.0),
        anno::description("Determines reflectivity"),
        anno::ui_order(6)
    ]],
    float reflectivity = 1.
    [[
        anno::display_name("Reflection weight"),
        anno::hard_range(0.0,1.),
        anno::description("Additional reflectivity control"),
        anno::ui_order(3)
    ]],
    float3 normal = state::normal()
    [[
        anno::display_name("Bumps"),
        anno::description("Attach bump or normal maps here"),
        anno::ui_order(7)
    ]]
)
[[
    anno::display_name("Plastic"),
    anno::description("A basic dielectric, works for everything opaque that is not metallic. Supports stretched highlights."),
    anno::thumbnail(".thumbs/scratched_plastic.png"),
    anno::in_group("Materials"),
    anno::ui_order(2),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(simple_material),
    anno::key_words(string[]("generic","dielectric","plastic","wood","stone"))
]]
 = let{
    base::anisotropy_return anisotropy_values = base::anisotropy_conversion(
        roughness: roughness*roughness,
        anisotropy: anisotropy,
        anisotropy_rotation: anisotropy_rotation
    );
    bsdf glossy_bsdf = df::microfacet_ggx_smith_bsdf(
        mode: df::scatter_reflect,
        tint: color(1.),
        roughness_u: anisotropy_values.roughness_u,
        roughness_v: anisotropy_values.roughness_v,
        tangent_u: anisotropy_values.tangent_u
    );
} in material(
    thin_walled: true,
    surface: material_surface(
        scattering: df::weighted_layer(
            weight: 1.,
            normal: normal,
            layer: df::fresnel_layer(
                ior: ior,
                weight: reflectivity,
                layer: glossy_bsdf,
                base: df::diffuse_reflection_bsdf(
                    roughness: 0.0,
                    tint: diffuse_color
                ),
                normal: normal
            )
        )
    )
);

export material retroreflective(
    color base_color = color(.2,.03,.03)
    [[
        anno::display_name("Color"),
        anno::description("The color of the material"),
        anno::ui_order(1)
    ]],
    color reflection_color = color(.8,.8,.03)
    [[
        anno::display_name("Reflection color"),
        anno::description("The color of the retroreflection"),
        anno::ui_order(2)
    ]],
    float roughness = 0.15
    [[
        anno::display_name("Roughness"),
        anno::hard_range(0.0,1.),
        anno::description("Higher roughness values lead to bigger highlights and blurry reflections"),
        anno::ui_order(3)
    ]],
    float normal_reflectivity = .05
    [[
        anno::display_name("Reflection weight facing"),
        anno::hard_range(0.0,1.),
        anno::description("Reflectivity control for geometry facing the viewer"),
        anno::ui_order(4)
    ]],
    float grazing_reflectivity = 1.
    [[
        anno::display_name("Reflection weight edge"),
        anno::hard_range(0.0,1.),
        anno::description("Reflectivity control for the reflectivity at geometry edges"),
        anno::ui_order(5)
    ]],
    float3 normal = state::normal()
    [[
        anno::display_name("Bumps"),
        anno::description("Attach bump or normal maps here"),
        anno::ui_order(7)
    ]]
)
[[
    anno::display_name("Retroreflective"),
    anno::description("A material with a retroreflective component, works well for road signs and retroreflective stickers"),
    anno::thumbnail(".thumbs/retroreflective.png"),
    anno::in_group("Materials"),
    anno::ui_order(3),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(simple_material),
    anno::key_words(string[]("generic","retroreflective","roadsign","stone"))
]]
 = let{
    bsdf glossy_bsdf = df::backscattering_glossy_reflection_bsdf(
        tint: reflection_color,
        roughness_u: roughness
    );
} in material(
    thin_walled: true,
    surface: material_surface(
        scattering: df::weighted_layer(
            weight: 1.,
            normal: normal,
            layer: df::custom_curve_layer(
                normal_reflectivity: 1.-normal_reflectivity,
                grazing_reflectivity: 1.-grazing_reflectivity,
                base: glossy_bsdf,
                layer: df::diffuse_reflection_bsdf(
                    roughness: 1.0,
                    tint: base_color
                ),
                normal: normal
            )
        )
    )
);

export material flex_material_v2(
    color base_color = color(.5)
    [[
        anno::display_name("Base color"),
        anno::in_group("Base"),
        anno::description("The color of the material"),
        anno::ui_order(1)
    ]],
    float diffuse_roughness = 0.0
    [[
        anno::display_name("Diffuse roughness"),
        anno::in_group("Base"),
        anno::hard_range(0.0,1.),
        anno::description("Higher roughness values lead to a more \"powdery\" look"),
        anno::ui_order(2)
    ]],
    float is_metal = 0.0
    [[
        anno::display_name("Metallic material"),
        anno::in_group("Base"),
        anno::description("If 1.0, reflection will be colored and independent of view direction. If 0.0, reflection will be white and direction dependent. Directional dependence is in this case based on the IOR (Fresnel effect)."),
        anno::ui_order(3)
    ]],
    float reflectivity = 1.0
    [[
        anno::display_name("Reflection weight"),
        anno::in_group("Base"),
        anno::hard_range(0.0,1.),
        anno::description("Controls the amount of reflection"),
        anno::ui_order(5)
    ]],
    float reflection_roughness = 0.3
    [[
        anno::display_name("Reflection roughness"),
        anno::in_group("Base"),
        anno::hard_range(0.0,1.),
        anno::description("Higher roughness values lead to more blurry reflections"),
        anno::ui_order(4)
    ]],
    float anisotropy = 0.0
    [[
        anno::display_name("Reflection anisotropy"),
        anno::in_group("Base"),
        anno::hard_range(0.0,1.),
        anno::description("Higher values will stretch the highlight"),
        anno::ui_order(6)
    ]],
    float anisotropy_rotation = 0.0
    [[
        anno::display_name("Anisotropy rotation"),
        anno::in_group("Base"),
        anno::hard_range(0.0,1.),
        anno::description("Changes the orientation of the anisotropy. A value of 1 will rotate the orientation 360 degrees."),
        anno::ui_order(7)
    ]],
    float transparency = 0.0
    [[
        anno::display_name("Transmission weight"),
        anno::in_group("Transmission"),
        anno::hard_range(0.0,1.),
        anno::description("Weights how much light passes through the object compared to its diffuse reflectivity."),
        anno::ui_order(12)
    ]],
    color transmission_color = color(1.)
    [[
        anno::display_name("Transmission color"),
        anno::in_group("Transmission"),
        anno::description("Color effect for transmission independent of thickness of the object, similar to stained glass."),
        anno::ui_order(8)
    ]],
    uniform color volume_color = color(1.0)
    [[
        anno::display_name("Volume color"),
        anno::in_group("Transmission"),
        anno::description("If the material is not \"Thin walled\", \"Volume color\" will be reached at \"Volume reference distance\" (m)."),
        anno::ui_order(9)
    ]],
    float transmission_roughness = 0.0
    [[
        anno::display_name("Transmission roughness"),
        anno::in_group("Transmission"),
        anno::hard_range(0.0,1.),
        anno::description("higher values lead to objects seen through the material to appear blurry"),
        anno::ui_order(11)
    ]],
    uniform float base_thickness = 0.1
    [[
        anno::display_name("Volume reference distance"),
        anno::in_group("Transmission"),
        anno::soft_range(0.0,10.0),
        anno::description("If the material is not \"Thin walled\", \"Volume color\" will be reached at this distance (m). Enter a typical thickness of objects made of this material here."),
        anno::ui_order(10)
    ]],
    uniform float ior = 1.5
    [[
        anno::display_name("IOR"),
        anno::in_group("Global"),
        anno::soft_range(1.0,4.0),
        anno::description("Determines refraction in the volume. It also influences the reflectivity for materials that are not metallic."),
        anno::ui_order(14)
    ]],
    uniform bool thin_walled = false
    [[
        anno::display_name("Thin walled"),
        anno::in_group("Global"),
        anno::description("Thin walled materials do not refract and do not have volume effects. Good for soap bubbles or window glass."),
        anno::ui_order(13)
    ]],
    float3 normal = state::normal()
    [[
        anno::display_name("Bumps"),
        anno::in_group("Global"),
        anno::description("Attach bump or normal maps here"),
        anno::ui_order(16)
    ]],
    uniform float abbe_number = 0.0
    [[
        anno::in_group("Global"),
        anno::display_name("Abbe number"),
        anno::description("Controls dispersion. A value of 0 switches dispersion off. Dispersive materials have Abbe numbers between 25 and 85"),
        anno::soft_range(0.0,100.0),
        anno::ui_order(15)
    ]]
)
[[
    anno::display_name("Flexible material model"),
    anno::description("A complex material that can be configured to a wide variety of looks"),
    anno::thumbnail(".thumbs/flex_material.png"),
    anno::author("NVIDIA Corporation"),
    anno::in_group("Materials"),
    anno::ui_order(5),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(complex_material),
    anno::key_words(string[]("generic","complex"))
]]
 = let{
    base::anisotropy_return anisotropy_values = base::anisotropy_conversion(
        roughness: reflection_roughness*reflection_roughness,
        anisotropy: anisotropy,
        anisotropy_rotation: anisotropy_rotation
    );
    bsdf glossy_bsdf = df::microfacet_ggx_smith_bsdf(
        mode: df::scatter_reflect,
        tint: color(1.),
        roughness_u: anisotropy_values.roughness_u,
        roughness_v: anisotropy_values.roughness_v,
        tangent_u: anisotropy_values.tangent_u
    );
    bsdf diffuse_bsdf = df::diffuse_reflection_bsdf(
        tint: base_color,
        roughness: diffuse_roughness
    );
    bsdf transmission_bsdf = df::microfacet_ggx_smith_bsdf(
        mode: df::scatter_transmit,
        tint: transmission_color,
        roughness_u: transmission_roughness*transmission_roughness
    );
    bsdf add_transparency = df::weighted_layer(
        weight: transparency,
        layer: transmission_bsdf,
        base: diffuse_bsdf,
        normal: normal
    );
    bsdf add_reflection = df::weighted_layer(
        is_metal,
        df::weighted_layer(
            weight: reflectivity,
            layer: df::directional_factor(base_color,color(1.0),5.,glossy_bsdf),
            base: add_transparency,
            normal: normal
        ),
        df::fresnel_layer(
            ior: ior,
            weight: reflectivity,
            layer: glossy_bsdf,
            base: add_transparency,
            normal: normal
        )
    );
    bsdf add_normal = df::weighted_layer(
        normal: normal,
        weight: 1.,
        layer: add_reflection
    );
} in material(
    thin_walled: thin_walled,
    ior: abbe_number == 0.0?color(ior):base::abbe_number_ior(ior, abbe_number),
    surface: material_surface(
        scattering: add_normal
    ),
    volume: material_volume(
        absorption_coefficient: (base_thickness <= 0)? color(0): math::log(volume_color) / -base_thickness
    )
);

export material thin_glass_v2(
    color glass_color = color(.95)
    [[
        anno::display_name("Transmission color"),
        anno::description("The color of the material")
    ]],
    float roughness = 0.0
    [[
        anno::display_name("Roughness"),
        anno::hard_range(0.0,1.),
        anno::description("Higher roughness values lead to bigger highlights and blurry reflections")
    ]],
    uniform float ior = 1.4
    [[
        anno::display_name("IOR"),
        anno::soft_range(1.0,4.0),
        anno::description("Determines reflectivity")
    ]],
    float3 normal = state::normal()
    [[
        anno::display_name("Bumps"),
        anno::description("Attach bump or normal maps here")
    ]]
)
[[
    anno::display_name("Thin glass"),
    anno::description("A basic transmissive dielectric without refraction or volume"),
    anno::thumbnail(".thumbs/thin_glass.png"),
    anno::in_group("Materials"),
    anno::ui_order(6),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(simple_material),
    anno::key_words(string[]("generic","dielectric","glass"))
]]
 = let{
    bsdf glossy_reflection_bsdf = df::microfacet_ggx_smith_bsdf(
        mode: df::scatter_reflect,
        tint: color(1.),
        roughness_u: roughness*roughness
    );
    bsdf glossy_transmission_bsdf = df::microfacet_ggx_smith_bsdf(
        mode: df::scatter_transmit,
        tint: glass_color,
        roughness_u: roughness
    );
} in material(
    thin_walled: true,
    surface: material_surface(
        df::fresnel_layer(
            ior: ior,
            normal: normal,
            layer: glossy_reflection_bsdf,
            base: df::weighted_layer(
                layer: glossy_transmission_bsdf,
                normal: normal,
                weight: 1.
            )
        )
    )
);

export material thin_translucent_v2(
    color surface_color = color(.95)
    [[
        anno::display_name("Diffuse color"),
        anno::description("The color of the material")
    ]],
    color translucent_color = color(.95)
    [[
        anno::display_name("Translucence color"),
        anno::description("The color of the volume of the material")
    ]],
    float translucency = 0.5
    [[
        anno::display_name("Translucence weight"),
        anno::hard_range(0.0,1.),
        anno::description("Fraction of the incoming light that should be visible on the backside")
    ]],
    float roughness = 0.0
    [[
        anno::display_name("Roughness"),
        anno::hard_range(0.0,1.),
        anno::description("Higher roughness values lead to bigger highlights and blurry reflections")
    ]],
    uniform float ior = 1.4
    [[
        anno::display_name("IOR"),
        anno::soft_range(1.0,4.0),
        anno::description("Determines reflectivity")
    ]],
    float3 normal = state::normal()
    [[
        anno::display_name("Bumps"),
        anno::description("Attach bump or normal maps here")
    ]]
)
[[
    anno::display_name("Thin translucent"),
    anno::description("A diffuse transmissive dielectric material"),
    anno::thumbnail(".thumbs/thin_translucent.png"),
    anno::in_group("Materials"),
    anno::ui_order(7),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(simple_material),
    anno::key_words(string[]("generic","dielectric","leaves","paper","sheets"))
]]
 = let{
    bsdf glossy_reflection_bsdf = df::microfacet_ggx_smith_bsdf(
        mode: df::scatter_reflect,
        tint: color(1.),
        roughness_u: roughness*roughness
    );
    bsdf transmission_bsdf = df::diffuse_transmission_bsdf(
        tint: translucent_color
    );
    bsdf base_bsdf = df::diffuse_reflection_bsdf(
        tint: surface_color
    );
} in material(
    thin_walled: true,
    surface: material_surface(
        df::fresnel_layer(
            ior: ior,
            normal: normal,
            layer: glossy_reflection_bsdf,
            base: df::weighted_layer(
                weight: translucency,
                normal: normal,
                base: base_bsdf,
                layer: df::weighted_layer(
                    layer: transmission_bsdf,
                    normal: normal,
                    weight: 1.
                )
            )
        )
    )
);

export material thick_glass_v2(
    color transmission_color = color(1.0)
    [[
        anno::ui_order(1),
        anno::display_name("Transmission color"),
        anno::description("Colors the light entering the volume, similar to stained glass")
    ]],
    uniform color glass_color = color(.95)
    [[
        anno::ui_order(2),
        anno::display_name("Volume color"),
        anno::description("The color of the glass body")
    ]],
    float roughness = 0.0
    [[
        anno::ui_order(4),
        anno::display_name("Roughness"),
        anno::hard_range(0.0,1.),
        anno::description("Higher roughness values lead to bigger highlights and blurry reflections")
    ]],
    uniform float ior = 1.4
    [[
        anno::ui_order(5),
        anno::display_name("IOR"),
        anno::soft_range(1.0,4.0),
        anno::description("Determines reflectivity as well as amount of refraction")
    ]],
    uniform float base_thickness = .1
    [[
        anno::ui_order(3),
        anno::display_name("Volume reference distance"),
        anno::soft_range(0.0,10.0),
        anno::description("\"Volume color\" will be reached at this distance (m). Enter a typical thickness of objects made of this material here.")

    ]],
    float3 normal = state::normal()
    [[
        anno::ui_order(7),
        anno::display_name("Bumps"),
        anno::description("Attach bump or normal maps here")
    ]],
    uniform float abbe_number = 0.0
    [[
        anno::ui_order(6),
        anno::display_name("Abbe number"),
        anno::description("Controls dispersion. 0 switches dispersion off. Dispersive materials have Abbe numbers between 25 and 85."),
        anno::soft_range(0.0,100.0)
    ]]
)
[[
    anno::display_name("Thick glass"),
    anno::description("A basic transmissive dielectric with refraction and coloring in the volume"),
    anno::thumbnail(".thumbs/thick_glass.png"),
    anno::in_group("Materials"),
    anno::ui_order(8),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(simple_material),
    anno::key_words(string[]("generic","dielectric","glass"))
]]
 = let{
    bsdf glossy_bsdf = df::microfacet_ggx_smith_bsdf(
        mode: df::scatter_reflect,
        tint: color(1.),
        roughness_u: roughness*roughness
    );
    bsdf glossy_bsdf_transmission = df::microfacet_ggx_smith_bsdf(
        mode: df::scatter_transmit,
        tint: transmission_color,
        roughness_u: roughness*roughness
    );
} in material(
    thin_walled: false,
    surface: material_surface(
        df::weighted_layer(
            normal: normal,
            weight: 1.,
            layer: df::fresnel_layer(
                layer: glossy_bsdf,
                base: glossy_bsdf_transmission,
                ior: ior,
                normal: normal
            )
        )
    ),
    volume: material_volume(
        absorption_coefficient: (base_thickness <= 0)? color(0): math::log(glass_color) / -base_thickness
    ),
    ior: abbe_number == 0.0?color(ior):base::abbe_number_ior(ior, abbe_number)
);

export material thick_translucent_v2(
    color transmission_color = color(.95)
    [[
        anno::display_name("Transmission color"),
        anno::description("The color of the material"),
        anno::ui_order(1)
    ]],
    uniform color volume_color = color(.95)
    [[
        anno::display_name("Volume color"),
        anno::description("The color of the volume at \"Volume reference distance\""),
        anno::ui_order(2)
    ]],
    uniform float volume_scattering = 0.5
    [[
        anno::display_name("Volume scattering"),
        anno::hard_range(0.0,.99999),
        anno::description("Amount of scattering for objects at \"Volume reference distance\""),
        anno::ui_order(3)
    ]],
    float roughness = 0.0
    [[
        anno::display_name("Reflection roughness"),
        anno::hard_range(0.0,1.),
        anno::description("Higher roughness values lead to bigger highlights and blurry reflections"),
        anno::ui_order(5)
    ]],
    float reflectivity = 1.
    [[
        anno::display_name("Reflection weight"),
        anno::hard_range(0.0,1.),
        anno::description("Overall reflectivity of the material"),
        anno::ui_order(6)
    ]],
    uniform float base_thickness = .1
    [[
        anno::display_name("Volume reference distance"),
        anno::soft_range(0.0,10.0),
        anno::description("\"Volume color\" and \"Volume scattering\" will be reached at this distance (m). Enter a typical thickness of objects made of this material here."),
        anno::ui_order(4)

    ]],
    float3 normal = state::normal()
    [[
        anno::display_name("Bumps"),
        anno::description("Attach bump or normal maps here"),
        anno::ui_order(9)
    ]],
    uniform float ior = 1.4
    [[
        anno::display_name("IOR"),
        anno::soft_range(1.0,4.0),
        anno::description("Determines reflectivity as well as amount of refraction"),
        anno::ui_order(7)
    ]],
    uniform float abbe_number = 0.0
    [[
        anno::display_name("Abbe number"),
        anno::description("Controls dispersion. A value of 0 switches dispersion off, Dispersive materials have Abbe numbers between 25 and 85."),
        anno::soft_range(0.0,100.0),
        anno::ui_order(8)
    ]]
)
[[
    anno::display_name("Thick translucent"),
    anno::description("A subsurface scattering material"),
    anno::thumbnail(".thumbs/thick_translucent.png"),
    anno::in_group("Materials"),
    anno::ui_order(9),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(simple_material),
    anno::key_words(string[]("generic","dielectric","wax","milk"))
]]
 = let{
    bsdf glossy_bsdf = df::microfacet_ggx_smith_bsdf(
        mode: df::scatter_reflect,
        tint: color(1.),
        roughness_u: roughness*roughness
    );
    bsdf transmission_bsdf = df::specular_bsdf(
        mode: df::scatter_transmit,
        tint: transmission_color
    );

} in material(
    thin_walled: false,
    surface: material_surface(
        df::fresnel_layer(
            normal: normal,
            weight: reflectivity,
            ior: ior,
            layer: glossy_bsdf,
            base: df::weighted_layer(
                normal: normal,
                weight: 1.,
                layer: transmission_bsdf
            )
        )
    ),
    volume: material_volume(
        scattering_coefficient: (base_thickness <= 0)? color(0): math::log(color(1.-volume_scattering)) / - base_thickness,
        absorption_coefficient: (base_thickness <= 0)? color(0): math::log(volume_color) / -base_thickness
    ),
    ior: abbe_number == 0.0?color(ior):base::abbe_number_ior(ior, abbe_number)
);

//endgroup

//group Modifier materials

export material blend(
    material base = scratched_plastic_v2()
    [[
        anno::display_name("Base material"),
        anno::description("The material the blend is based on")
    ]],
    material blend =  scratched_metal_v2()
    [[
        anno::display_name("Blend Material"),
        anno::description("Surface properties to use for the blend")
    ]],
    float weight = 0.
    [[
        anno::display_name("Blend weight"),
        anno::hard_range(0.0,1.),
        anno::description("Blend weight or mask texture")
    ]]
)
[[
    anno::display_name("Surface blender"),
    anno::description("Blend surface characteristics of 2 materials or mask them using a texture"),
    anno::thumbnail(".thumbs/blend.png"),
    anno::in_group("Materials, modifiers"),
    anno::ui_order(15),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(combiner_material),
    anno::key_words(string[]("combiner","generic"))
]]
 =  material(
    surface: material_surface(
        scattering: df::weighted_layer(
            weight: weight,
            layer: blend.surface.scattering,
            base: base.surface.scattering
        ),
        emission: base.surface.emission
    ),
    volume: base.volume,
    ior: base.ior,
    thin_walled: base.thin_walled,
    geometry: base.geometry
);

export material surface_falloff(
    material base = scratched_plastic_v2()
    [[
        anno::display_name("Base material"),
        anno::description("The material the blend is based on")
    ]],
    material blend =  scratched_metal_v2()
    [[
        anno::display_name("Blend Material"),
        anno::description("Surface properties to use for the blend")
    ]],
    float facing_weight = 0.0
    [[
        anno::display_name("Blend weight facing"),
        anno::hard_range(0.0,1.),
        anno::description("Blend weight or mask texture")
    ]],
    float edge_weight = 1.0
    [[
        anno::display_name("Blend weight edge"),
        anno::hard_range(0.0,1.),
        anno::description("Blend weight or mask texture")
    ]],
    float blend_bias = 1.
    [[
        anno::display_name("Blend bias"),
        anno::soft_range(0.0,10.),
        anno::description("Controls how fast the transition should happen. 5.0 results in fresnel like transition.")
    ]]
)
[[
    anno::display_name("Surface falloff"),
    anno::description("Blend surface characteristics of 2 materials or mask them using a texture"),
    anno::thumbnail(".thumbs/surface_falloff.png"),
    anno::in_group("Materials, modifiers"),
    anno::ui_order(15),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(combiner_material),
    anno::key_words(string[]("combiner","generic"))
]]
 =  material(
    surface: material_surface(
        scattering: df::custom_curve_layer(
            weight: 1.,
            exponent: blend_bias,
            normal_reflectivity: facing_weight,
            grazing_reflectivity: edge_weight,
            layer: blend.surface.scattering,
            base: base.surface.scattering
        ),
        emission: base.surface.emission
    ),
    volume: base.volume,
    ior: base.ior,
    thin_walled: base.thin_walled,
    geometry: base.geometry
);

export material apply_clearcoat_v2(
    material base = diffuse(diffuse_color: color(0.))
    [[
        anno::display_name("Base material"),
        anno::description("The material that will get a clear coating applied"),
        anno::ui_order(1)
    ]],
    uniform float ior = 1.6
    [[
        anno::display_name("IOR"),
        anno::soft_range(1.0,4.0),
        anno::description("Determines reflectivity of the clear coat"),
        anno::ui_order(5)
    ]],
    float roughness = 0.0
    [[
        anno::display_name("Reflection roughness"),
        anno::hard_range(0.0,1.0),
        anno::description("Determines roughness of the clear coat"),
        anno::ui_order(3)
    ]],
    float visibility = 1.0
    [[
        anno::display_name("Coat visibility"),
        anno::hard_range(0.0,1.0),
        anno::description("Determines visibility of the clear coat"),
        anno::ui_order(4)
    ]],
    float3 normal = state::normal()
    [[
        anno::display_name("Bumps"),
        anno::description("Attach bump or normal maps here"),
        anno::ui_order(6)
    ]],
    color coat_filter_color = color(1.)
    [[
        anno::display_name("Coat filter color"),
        anno::description("For simulating coatings with colored resins that modulate the color of underlying layers"),
        anno::ui_order(2)
    ]]
)
[[
    anno::display_name("Apply clear coating"),
    anno::description("Apply clear coat to an existing material"),
    anno::author("NVIDIA Corporation"),
    anno::thumbnail(".thumbs/apply_clearcoat.png"),
    anno::in_group("Materials, modifiers"),
    anno::ui_order(16),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(modifier_material),
    anno::key_words(string[]("modifier","generic","coating"))
]]
 = let{
    bsdf glossy_bsdf = df::microfacet_ggx_smith_bsdf(
        mode: df::scatter_reflect,
        roughness_u: roughness*roughness,
        tint: color(1.)
    );
    color base_tint = blend_colors(color(1.), coat_filter_color, color_layer_blend, visibility).tint;
} in material(
    surface: material_surface(
        scattering: df::fresnel_layer(
            ior: ior,
            normal: normal,
            weight: visibility,
            layer: glossy_bsdf,
            base: df::tint(tint: base_tint, base: base.surface.scattering)
        ),
        emission: base.surface.emission
    ),
    volume: base.volume,
    ior: base.ior,
    thin_walled: base.thin_walled,
    geometry: base.geometry
);

export material apply_thinfilm(
    material base = scratched_metal_v2()
    [[
        anno::display_name("Base material"),
        anno::description("The material that will get shows a thin film effect")
    ]],
    uniform float ior = 1.6
    [[
        anno::display_name("IOR"),
        anno::soft_range(1.0,4.0),
        anno::description("The IOR of the thin film interface")
    ]],
    float thickness = 400.0
    [[
        anno::display_name("Thickness"),
        anno::soft_range(10.0,5000.0),
        anno::description("Thickness of the thin film in nm")
    ]])
[[
    anno::display_name("Apply thin film"),
    anno::description("Apply thin film to an existing material"),
    anno::thumbnail(".thumbs/apply_thinfilm.png"),
    anno::in_group("Materials, modifiers"),
    anno::ui_order(17),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(modifier_material),
    anno::key_words(string[]("modifier","generic","coating"))
]]
 =  material(
    surface: material_surface(
        scattering: df::thin_film(
            ior: color(ior),
            thickness: thickness,
            base: base.surface.scattering
        ),
        emission: base.surface.emission
    ),
    volume: base.volume,
    ior: base.ior,
    thin_walled: base.thin_walled,
    geometry: base.geometry
);

export material apply_metalcoat_v2(
    material base = diffuse(diffuse_color: color(0.))
    [[
        anno::display_name("Base material"),
        anno::description("The material that will get a metallic coating applied"),
        anno::ui_order(1)
    ]],
    color metal_color = color(.95)
    [[
        anno::display_name("Reflection color"),
        anno::description("The color of the metal"),
        anno::ui_order(2)
    ]],
    float visibility = .3
    [[
        anno::display_name("Reflection weight"),
        anno::hard_range(0.0,1.0),
        anno::description("The opacity of the coat"),
        anno::ui_order(4)
    ]],
    float roughness = 0.0
    [[
        anno::display_name("Reflection roughness"),
        anno::hard_range(0.0,1.0),
        anno::description("Determines roughness of the metal coat"),
        anno::ui_order(3)
    ]],
    float3 normal = state::normal()
    [[
        anno::display_name("Bumps"),
        anno::description("Attach bump or normal maps here"),
        anno::ui_order(5)
    ]]
)
[[
    anno::display_name("Apply thin metal coating"),
    anno::description("Apply metal coat to an existing material"),
    anno::thumbnail(".thumbs/apply_metalcoat.png"),
    anno::in_group("Materials, modifiers"),
    anno::ui_order(18),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(modifier_material),
    anno::key_words(string[]("modifier","generic","coating"))
]]
 = let{
    bsdf glossy_bsdf = df::microfacet_ggx_smith_bsdf(
        mode: df::scatter_reflect,
        roughness_u: roughness*roughness,
        tint: metal_color
    );
} in material(
    surface: material_surface(
        scattering: df::weighted_layer(
            weight: visibility,
            normal: normal,
            layer: glossy_bsdf,
            base: base.surface.scattering
        ),
        emission: base.surface.emission
    ),
    volume: base.volume,
    ior: base.ior,
    thin_walled: base.thin_walled,
    geometry: base.geometry
);

export material apply_dustcover(
    material base = diffuse(diffuse_color: color(0.))
    [[
        anno::display_name("Base material"),
        anno::description("The material that will get a clear coating applied")
    ]],
    color dust_color = color(.7)
    [[
        anno::display_name("Dust color"),
        anno::description("The color of the dust")
    ]],
    float visibility = 1.
    [[
        anno::display_name("Dust density"),
        anno::hard_range(0.0,1.0),
        anno::description("The opacity of the cover")
    ]],
    uniform float dust_density = .5
    [[
        anno::display_name("Dust amount"),
        anno::hard_range(.01,1),
        anno::description("How dusty the material is")
    ]],
    float3 normal = state::normal()
    [[
        anno::display_name("Bumps"),
        anno::description("Attach bump or normal maps here")
    ]]
)
[[
    anno::display_name("Apply a cover of dust"),
    anno::description("Apply a diffuse cover of dust or dirt"),
    anno::thumbnail(".thumbs/apply_dustcover.png"),
    anno::in_group("Materials, modifiers"),
    anno::ui_order(19),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(modifier_material),
    anno::key_words(string[]("modifier","generic","coating"))
]]
 = let{
    bsdf dust_bsdf = df::diffuse_reflection_bsdf(
        roughness: 1.,
        tint: dust_color
    );
} in material(
    surface: material_surface(
        scattering: df::custom_curve_layer(
            weight: visibility,
            normal_reflectivity: dust_density*dust_density*dust_density,
            exponent: (1.05-dust_density)*2.,
            normal: normal,
            layer: dust_bsdf,
            base: base.surface.scattering
        ),
        emission: base.surface.emission
    ),
    volume: base.volume,
    ior: base.ior,
    thin_walled: base.thin_walled,
    geometry: base.geometry
);

export material apply_colorfalloff_v2(
    material base = scratched_metal_v2(metal_color: color(1.))
    [[
        anno::display_name("Base material"),
        anno::description("The material that will get a clear coating applied")
    ]],
    uniform color color_0 = color(1.,0.,0.)
    [[
        anno::display_name("Color 1"),
        anno::description("Color 1 (facing direction)")
    ]],
    uniform color color_1 = color(0.,1.,0.)
    [[
        anno::display_name("Color 2"),
        anno::description("Color 2")
    ]],
    uniform color color_2 = color(0.,0.,1.)
    [[
        anno::display_name("Color 3"),
        anno::description("Color 3")
    ]],
    uniform color color_3 = color(1.,0.,0.)
    [[
        anno::display_name("Color 4"),
        anno::description("Color 4")
    ]],
    uniform color color_4 = color(0.,1.,0.)
    [[
        anno::display_name("Color 5"),
        anno::description("Color 5 (object edges)")
    ]]
)
[[
    anno::display_name("Apply a color falloff"),
    anno::description("Makes the color view dependent"),
    anno::thumbnail(".thumbs/apply_colorfalloff.png"),
    anno::author("NVIDIA Corporation"),
    anno::in_group("Materials, modifiers"),
    anno::ui_order(20),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(modifier_material),
    anno::key_words(string[]("modifier","generic","coating"))
]]
 =  material(
    surface: material_surface(
        scattering: df::measured_curve_factor(
            curve_values: color[](color_0,color_1,color_2,color_3,color_4),
            base: base.surface.scattering
        ),
        emission: base.surface.emission
    ),
    volume: base.volume,
    ior: base.ior,
    thin_walled: base.thin_walled,
    geometry: base.geometry
);
//JAN: TODO fix from here
export material apply_metallicflakes(
    material base = diffuse(diffuse_color: color(0.))
    [[
        anno::display_name("Base material"),
        anno::description("The material that will get a flake layer applied")
    ]],
    color flake_color = color(.9,.7,.5)
    [[
        anno::display_name("Color"),
        anno::description("The color of the flakes")
    ]],

    float roughness = 0.0
    [[
        anno::display_name("Roughness"),
        anno::hard_range(0.0,1.0),
        anno::description("Determines roughness of the metallic flakes")
    ]],
    uniform float size = 1.
    [[
        anno::display_name("Flake size"),
        anno::description("Determines size of the metallic flakes, in mm")
    ]],
    uniform float amount = 0.5
    [[
        anno::display_name("Flake amount"),
        anno::hard_range(0.0,1.),
        anno::description("Determines amount of visible metallic flakes")
    ]],
    uniform float opacity = 0.5
    [[
        anno::display_name("Flake opacity"),
        anno::hard_range(0.0,1.),
        anno::description("Determines visibility of the metallic flakes")
    ]],
    uniform float bump = 1.
    [[
        anno::display_name("Flake orientation randomness"),
        anno::description("Larger numbers will increase the sparkle radius around highlights")
    ]]
)
[[
    anno::display_name("Apply flake coating"),
    anno::description("Apply layer of metallic flakes to an existing material"),
    anno::thumbnail(".thumbs/apply_metallicflakes.png"),
    anno::in_group("Materials, modifiers"),
    anno::ui_order(21),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(modifier_material),
    anno::key_words(string[]("modifier","generic","coating"))
]]
 = let{
    float3 flake_normal = base::flake_noise_bump_texture(
        uvw: base::coordinate_source(coordinate_system: base::texture_coordinate_object),
        strength: bump,
        scale: size * 0.001
    );
    float flake_opacity = base::flake_noise_texture(
        uvw: base::coordinate_source(coordinate_system: base::texture_coordinate_object),
        intensity: opacity,
        scale: size * 0.001,
        density: amount
    ).mono;

    bsdf glossy_bsdf = df::simple_glossy_bsdf(
        mode: df::scatter_reflect,
        roughness_u: roughness,
        tint: flake_color
    );
} in material(
    surface: material_surface(
        scattering: df::weighted_layer(
            normal: flake_normal,
            weight: flake_opacity,
            layer: glossy_bsdf,
            base: base.surface.scattering
        ),
        emission: base.surface.emission
    ),
    volume: base.volume,
    ior: base.ior,
    thin_walled: base.thin_walled,
    geometry: base.geometry
);

export material flake_paint(
    color base_color = color(.3,.01,.01)
    [[
        anno::display_name("Base color"),
        anno::description("The color of the base paint")
    ]],
    color flake_color = color(.6,1,.1)
    [[
        anno::display_name("Flake color"),
        anno::description("The color of the flakes")
    ]],
    float roughness = 0.15
    [[
        anno::display_name("Flake roughness"),
        anno::hard_range(0.0,1.0),
        anno::description("Determines roughness of the metallic flakes")
    ]],
    uniform float size = 1.
    [[
        anno::display_name("Flake size"),
        anno::description("Determines size of the metallic flakes, in mm")
    ]],
    uniform float amount = 0.4
    [[
        anno::display_name("Flake amount"),
        anno::hard_range(0.0,1.),
        anno::description("Determines amount of visible metallic flakes")
    ]],
    uniform float opacity = .8
    [[
        anno::display_name("Flake weight"),
        anno::hard_range(0.0,1.),
        anno::description("Determines visibility of the metallic flakes")
    ]],
    uniform float bump = 1.
    [[
        anno::display_name("Flake orientation randomness"),
        anno::description("Larger numbers will increase the sparkle radius around highlights")
    ]],
        uniform float ior = 1.6
    [[
        anno::display_name("IOR"),
        anno::soft_range(1.0,4.0),
        anno::description("Determines reflectivity of the clear coat")
    ]],
    float coat_roughness = 0.0
    [[
        anno::display_name("Coat roughness"),
        anno::hard_range(0.0,1.0),
        anno::description("Determines roughness of the clear coat")
    ]],
    float3 coat_bump = state::normal()
    [[
        anno::display_name("Coat bump"),
        anno::description("Attach bump or normal maps here")
    ]]

)
[[
    anno::display_name("Flaky paint"),
    anno::description("A multi layer paint material containing flakes"),
    anno::thumbnail(".thumbs/flake_paint.png"),
    anno::author("NVIDIA Corporation"),
    anno::in_group("Materials"),
    anno::ui_order(14),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(complex_material),
    anno::key_words(string[]("complex","carpaint"))
]]
 = let{
    float3 flake_normal = base::flake_noise_bump_texture(
        uvw: base::coordinate_source(coordinate_system: base::texture_coordinate_object),
        strength: bump,
        scale: size * 0.001
    );
    float flake_opacity = base::flake_noise_texture(
        uvw: base::coordinate_source(coordinate_system: base::texture_coordinate_object),
        intensity: opacity,
        scale: size * 0.001,
        density: amount
    ).mono;

    bsdf glossy_bsdf = df::simple_glossy_bsdf(
        mode: df::scatter_reflect,
        roughness_u: roughness,
        tint: flake_color
    );
} in material(
    surface: material_surface(
        scattering: df::fresnel_layer(
            ior: ior,
            normal: coat_bump,
            layer: df::simple_glossy_bsdf(roughness_u: coat_roughness),
            base: df::weighted_layer(
                normal: flake_normal,
                weight: flake_opacity,
                layer: glossy_bsdf,
                base: df::diffuse_reflection_bsdf(tint: base_color)
            )
        )
    ),
    thin_walled: true
);

export material add_cutout(
    material base = scratched_plastic_v2()
    [[
        anno::display_name("Base material"),
        anno::description("The material that will get a cut-out")
    ]],
    float cutout = 1.0
    [[
        anno::display_name("Cutout"),
        anno::hard_range(0.0,1.0),
        anno::description("Determines where the object is visible")
    ]]
) [[
    anno::display_name("Add cut-outs"),
    anno::description("Adds cut-outs to existing materials. Also forces material to be thin-walled. Good for modeling leaves, grass or fences."),
    anno::thumbnail(".thumbs/add_cutout.png"),
    anno::in_group("Materials, modifiers"),
    anno::ui_order(22),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(modifier_material),
    anno::key_words(string[]("modifier","generic"))
]] = material(
    surface: base.surface,
    volume: base.volume,
    ior: base.ior,
    thin_walled: true,
    geometry: material_geometry(
        displacement: base.geometry.displacement,
        normal: base.geometry.normal,
        cutout_opacity: cutout
    )
);

export material add_simple_sticker(
    color diffuse_color = color(.5)
    [[
        anno::display_name("Sticker color"),
        anno::description("The color of the material"),
        anno::ui_order(2)
    ]],
    float roughness = 0.05
    [[
        anno::display_name("Sticker roughness"),
        anno::hard_range(0.0,1.),
        anno::description("Higher roughness values lead to bigger highlights and blurry reflections"),
        anno::ui_order(3)
    ]],
    uniform float ior = 1.4
    [[
        anno::display_name("Sticker IOR"),
        anno::soft_range(1.0,4.0),
        anno::description("Determines reflectivity"),
        anno::ui_order(6)
    ]],
    float reflectivity = 1.
    [[
        anno::display_name("Sticker reflectivity"),
        anno::hard_range(0.0,1.),
        anno::description("Additional Reflectivity control"),
        anno::ui_order(4)
    ]],
    float3 sticker_normal = state::normal()
    [[
        anno::display_name("Sticker bumps"),
        anno::description("Attach bump or normal maps here"),
        anno::ui_order(7)
    ]],
    float sticker_mask = 0.0
    [[
        anno::display_name("Sticker mask"),
        anno::hard_range(0.0,1.0),
        anno::description("Determines extent of the sticker"),
        anno::ui_order(5)
    ]],
    material base = scratched_plastic_v2()
    [[
        anno::display_name("Base material"),
        anno::description("The material that will get a sticker added"),
        anno::ui_order(1)
    ]]
) [[
    anno::display_name("Add simple sticker"),
    anno::description("A quick way for adding simple stickers to a material. The sticker is a simple dielectric and needs a mask to define its extent."),
    anno::thumbnail(".thumbs/add_simple_sticker.png"),
    anno::author("NVIDIA Corporation"),
    anno::in_group("Materials, modifiers"),
    anno::ui_order(23),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(modifier_material),
    anno::key_words(string[]("modifier","generic"))
]] = let{
    material blend_material = blend(
        blend: scratched_plastic_v2(
            diffuse_color: diffuse_color,
            roughness: roughness,
            ior: ior,
            reflectivity: reflectivity,
            normal: sticker_normal),
        base: base,
        weight: sticker_mask
        );
} in material(
    surface: blend_material.surface,
    volume: base.volume,
    ior: base.ior,
    thin_walled: base.thin_walled,
    geometry: material_geometry(
        displacement: base.geometry.displacement,
        normal: base.geometry.normal,
        cutout_opacity: base.geometry.cutout_opacity
    )
);

export material add_globalbump(
    material base = scratched_plastic_v2()
    [[
        anno::display_name("Base material"),
        anno::description("The material that will get a bump map")
    ]],
    float3 normal = state::normal()
    [[
        anno::display_name("Bump"),
        anno::description("An additional global bump map for the material. Local bump map of the base material is preserved.")
    ]]
) [[
    anno::display_name("Add global bumpmap"),
    anno::description("Adds global bumpmap to existing materials. Local bump map of the base material is preserved."),
    anno::thumbnail(".thumbs/add_globalbump.png"),
    anno::author("NVIDIA Corporation"),
    anno::in_group("Materials, modifiers"),
    anno::ui_order(24),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(modifier_material),
    anno::key_words(string[]("modifier","generic"))
]] = material(
    surface: base.surface,
    volume: base.volume,
    ior: base.ior,
    thin_walled: base.thin_walled,
    geometry: material_geometry(
        displacement: base.geometry.displacement,
        normal: normal,
        cutout_opacity: base.geometry.cutout_opacity
    )
);

export material add_displacement(
    material base = scratched_plastic_v2()
    [[
        anno::display_name("Base material"),
        anno::description("The material that will get a bump map")
    ]],
    float displacement = 0.0
    [[
        anno::display_name("Displacement amount"),
        anno::description("Attach displacement texture here. Note that the object needs to be set up correctly to have good displacement results.")
    ]],
    uniform float displacement_scale = 1.0
    [[
        anno::display_name("Displacement scale"),
        anno::description("A global scale factor for the displacement amount")
    ]]
) [[
    anno::display_name("Add displacement"),
    anno::description("Adds displacement to existing materials"),
    anno::thumbnail(".thumbs/add_displacement.png"),
    anno::author("NVIDIA Corporation"),
    anno::in_group("Materials, modifiers"),
    anno::ui_order(25),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(modifier_material),
    anno::key_words(string[]("modifier","generic"))
]] = material(
    surface: base.surface,
    volume: base.volume,
    ior: base.ior,
    thin_walled: base.thin_walled,
    geometry: material_geometry(
        displacement: displacement*displacement_scale*state::scene_units_per_meter()*state::normal(),
        normal: base.geometry.normal,
        cutout_opacity: base.geometry.cutout_opacity
    )
);

export material add_emission(
    material base = diffuse(diffuse_color: color(0.))
    [[
        anno::display_name("Base material"),
        anno::description("The material that will get emission added")
    ]],
    color tint = color(1.)
    [[
        anno::display_name("Color"),
        anno::description("The color of the light")
    ]],
    uniform float intensity = 1000
    [[
        anno::display_name("Intensity"),
        anno::description("The brightness of the light source")
    ]],
    uniform float unit_scale = 1.
    [[
        anno::display_name("Unit scale"),
        anno::hidden(), //deprecated
        anno::description("Modeling unit to meter conversion factor")
    ]],
    uniform emission_type unit = lumen_m2
    [[
        anno::display_name("Unit for emission"),
        anno::description("The physical unit of \"Intensity\"")
    ]]
) [[
    anno::display_name("Add emission"),
    anno::description("Adds emission to a material"),
    anno::thumbnail(".thumbs/add_emission.png"),
    anno::author("NVIDIA Corporation"),
    anno::in_group("Materials, modifiers"),
    anno::ui_order(26),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(modifier_material),
    suitable_as_light(),
    anno::key_words(string[]("modifier","generic"))
]] =
let {
    uniform float unit_intensity = (unit==lumen || unit==lumen_m2)?intensity:intensity*math::PI; //diffuse emission is per projected hemisphere
    uniform intensity_mode imode = (unit==lumen || unit==candela)?intensity_power:intensity_radiant_exitance;
}
in material(
    surface: material_surface(
        scattering: base.surface.scattering,
        emission: material_emission(
            emission: df::diffuse_edf(),
            intensity: unit_intensity*tint*unit_scale, //for this mode, tint is assumes to be a color filter absorbing light
            mode: imode
        )
    ),
    volume: base.volume,
    ior: base.ior,
    thin_walled: base.thin_walled,
    geometry: base.geometry
);

export material add_thermal_emission(
    material base = diffuse(diffuse_color: color(0.))
    [[
        anno::display_name("Base material"),
        anno::description("The material that will get emission added")
    ]],
    uniform float temperature = 6500.
    [[
        anno::display_name("Temperature"),
        anno::description("The color temperature of the light in Kelvin")
    ]],
    uniform float intensity = 1000
    [[
        anno::display_name("Intensity"),
        anno::description("The brightness of the light source")
    ]],
    uniform emission_type unit = lumen_m2
    [[
        anno::display_name("Unit for emission"),
        anno::description("The physical unit of \"Intensity\"")
    ]]
) [[
    anno::display_name("Add thermal emission"),
    anno::description("Adds emission to a material, color is based on a \"color temperature\""),
    anno::thumbnail(".thumbs/add_thermal_emission.png"),
    anno::author("NVIDIA Corporation"),
    anno::in_group("Materials, modifiers"),
    anno::ui_order(27),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(modifier_material),
    suitable_as_light(),
    anno::key_words(string[]("modifier","generic"))
]] =
let {
    uniform float unit_intensity = (unit==lumen || unit==lumen_m2)?intensity:intensity*math::PI; //diffuse emission is per projected hemisphere
    uniform intensity_mode imode = (unit==lumen || unit==candela)?intensity_power:intensity_radiant_exitance;
    color emission_color = math::blackbody(temperature);

    color scaled_intensity = unit_intensity * (emission_color / math::luminance(emission_color));}
in material(
    surface: material_surface(
        scattering: base.surface.scattering,
        emission: material_emission(
            emission: df::diffuse_edf(),
            intensity: scaled_intensity,
            mode: imode
        )
    ),
    volume: base.volume,
    ior: base.ior,
    thin_walled: base.thin_walled,
    geometry: base.geometry
);
//endgroup

/**-*/

//group Emissive materials

export material light_omni (
    color tint = color(1.)
    [[
        anno::display_name("Color"),
        anno::description("The color of the light")
    ]],
    uniform float intensity = 1000
    [[
        anno::display_name("Intensity"),
        anno::description("The brightness of the light source")
    ]],
    uniform float unit_scale = 1.
    [[
        anno::display_name("Unit scale"),
        anno::hidden(), //deprecated
        anno::description("Modeling unit to meter conversion factor")
    ]],
    uniform emission_type unit = lumen_m2
    [[
        anno::display_name("Unit for emission"),
        anno::description("The physical unit of \"Intensity\"")
    ]]
) [[
    anno::display_name("Diffuse emission"),
    anno::description("Emissive material emitting in all directions"),
    anno::thumbnail(".thumbs/light_omni.png"),
    anno::author("NVIDIA Corporation"),
    anno::in_group("Materials, lights"),
    anno::ui_order(5000),
    anno::hidden(),
    anno::copyright_notice(COPYRIGHT),
    anno::key_words(string[]("lightsource")),
    suitable_as_light()
]] =
let{
    uniform float unit_intensity = (unit==lumen || unit==lumen_m2)?intensity:intensity*math::PI; //diffuse emission is per projected hemisphere
    uniform intensity_mode imode = (unit==lumen || unit==candela)?intensity_power:intensity_radiant_exitance;
} in material (
    surface: material_surface (
        emission: material_emission (
            emission: df::diffuse_edf(),
            intensity: tint*unit_intensity*unit_scale,
            mode: imode
        )
    )
);

export material light_spot (
    color tint = color(1.)
    [[
        anno::display_name("Color"),
        anno::description("The color of the light")
    ]],
    uniform float intensity = 1000
    [[
        anno::display_name("Intensity"),
        anno::description("The brightness of the light source")
    ]],
    uniform float unit_scale = 1.
    [[
        anno::display_name("Unit scale"),
        anno::hidden(), //deprecated
        anno::description("Modeling unit to meter conversion factor")
    ]],
    uniform float spot_exponent = 30
    [[
        anno::display_name("Spot focus"),
        anno::description("larger values lead to more focused spotlights")
    ]],
    uniform emission_type unit = lumen_m2
    [[
        anno::display_name("Unit for emission"),
        anno::description("The physical unit of \"Intensity\"")
    ]]
) [[
    anno::display_name("Spotlight emission"),
    anno::description("Emissive material emitting focused in one direction"),
    anno::thumbnail(".thumbs/light_spot.png"),
    anno::author("NVIDIA Corporation"),
    anno::in_group("Materials, lights"),
    anno::hidden(),
    anno::ui_order(5051),
    anno::copyright_notice(COPYRIGHT),
    anno::key_words(string[]("lightsource")),
    suitable_as_light()
]]  =
let{
    //since this is a spotlight, we need the apex angle to convert from candela to lumen
    //http://www.compuphase.com/electronics/candela_lumen.htm
    //uniform float cos_apexangle_2 = math::pow(0.5,1./spot_exponent); //spot exponent 0 ->4pi
    //uniform float apexfactor = 2*math::PI*(1.0-cos_apexangle_2);

    //correct integral
    uniform float factor = (spot_exponent == 0)? 4*math::PI: 2*math::PI/(spot_exponent+1);
    uniform float unit_intensity = (unit==lumen || unit==lumen_m2)?intensity:intensity*factor;
    uniform intensity_mode imode = (unit==lumen || unit==candela)?intensity_power:intensity_radiant_exitance;
} in  material (
    surface: material_surface (
        emission:  material_emission (
            emission: df::spot_edf(exponent: spot_exponent,global_distribution: true, global_frame: float3x3(1.,0,0,   0,1.,0.,  0.,0,-1) ),
            intensity: tint*unit_intensity*unit_scale,
            mode: imode
        )
    )
);

export material light_ies (
    uniform light_profile profile
    [[
        anno::display_name("IES light profile data"),
        anno::description("Data to describe the distribution of the light")
    ]],
    color tint = color(1.)
    [[
        anno::display_name("Color"),
        anno::description("The color of the light")
    ]],
    uniform float intensity = 1
    [[
        anno::display_name("Intensity"),
        anno::description("The brightness of the light source")
    ]],
    uniform float unit_scale = 1.
    [[
        anno::display_name("Unit scale"),
        anno::hidden(),//deprecated
        anno::description("Modeling unit to meter conversion factor")
    ]]
) [[
    anno::display_name("IES file based emission"),
    anno::description("Emissive material emitting as described in an IES file"),
    anno::thumbnail(".thumbs/light_ies.png"),
    anno::author("NVIDIA Corporation"),
    anno::in_group("Materials, lights"),
    anno::hidden(),
    anno::ui_order(5052),
    anno::copyright_notice(COPYRIGHT),
    anno::key_words(string[]("lightsource")),
    suitable_as_light()
]]   = material (
    surface: material_surface (
        emission:  material_emission (
            emission: df::measured_edf(profile: profile,global_distribution: true, global_frame: float3x3(1.,0,0,   0,1.,0.,  0.,0,-1) ),
            intensity: tint*intensity*unit_scale
        )
    )
);

//endgroup

//group Deprecated

//deprecated functionality===========================================================================================
export annotation ui_position(int position);
export annotation typical_object_size(float size);

export material metal(
    color metal_color = color(.9)
    [[
        anno::display_name("Color"),
        anno::description("The color of the metal")
    ]],
    float roughness = 0.05
    [[
        anno::display_name("Roughness"),
        anno::hard_range(0.0,1.),
        anno::description("Higher roughness values lead to bigger highlights and blurry reflections")
    ]],
    float glossy_weight = .9
    [[
        anno::display_name("Reflectivity"),
        anno::hard_range(0.0,1.),
        anno::description("Intensity of highlights and glossy reflections and highlights")
    ]],
    float3 normal = state::normal()
    [[
        anno::display_name("Bumps"),
        anno::description("Attach bump or normal maps here")
    ]]
)
[[
    anno::display_name("Simple metal, deprecated"),
    anno::description("A basic metallic material"),
    anno::thumbnail(".thumbs/metal.png"),
    anno::author("NVIDIA Corporation"),
    anno::hidden(),
    //anno::deprecated("Use scratched_metal_v2"),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(simple_material),
    anno::key_words(string[]("generic","metal"))
]]
 = let{
    bsdf glossy_bsdf = df::simple_glossy_bsdf(
        mode: df::scatter_reflect,
        tint: metal_color,
        roughness_u: roughness
    );
} in material(
    thin_walled: true,
    surface: material_surface(
        scattering: df::weighted_layer(
            weight: 1.,
            normal: normal,
            layer: df::weighted_layer(
                weight: glossy_weight,
                layer: glossy_bsdf,
                base: df::diffuse_reflection_bsdf(
                    roughness: 0.0,
                    tint: metal_color
                ),
                normal: normal
            )
        )
    )
);

export material plastic(
    color diffuse_color = color(.5)
    [[
        anno::display_name("Color"),
        anno::description("The color of the material")
    ]],
    float roughness = 0.25
    [[
        anno::display_name("Roughness"),
        anno::hard_range(0.0,1.),
        anno::description("Higher roughness values lead to bigger highlights and blurry reflections")
    ]],
    uniform float ior = 1.4
    [[
        anno::display_name("IOR"),
        anno::soft_range(1.0,4.0),
        anno::description("Determines reflectivity")
    ]],
    float3 normal = state::normal()
    [[
        anno::display_name("Bumps"),
        anno::description("Attach bump or normal maps here")
    ]]
)
[[
    anno::display_name("Simple plastic, deprecated"),
    anno::description("A basic dielectric, works for everything opaque that is not metallic"),
    anno::thumbnail(".thumbs/plastic.png"),
    anno::author("NVIDIA Corporation"),
    anno::hidden(),
    //anno::deprecated("Use scratched_plastic_v2"),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(simple_material),
    anno::key_words(string[]("generic","dielectric","plastic","wood","stone"))
]]
 = let{
    bsdf glossy_bsdf = df::simple_glossy_bsdf(
        mode: df::scatter_reflect,
        tint: color(1.),
        roughness_u: roughness
    );
} in material(
    thin_walled: true,
    surface: material_surface(
        scattering: df::weighted_layer(
            weight: 1.,
            normal: normal,
            layer: df::fresnel_layer(
                ior: ior,
                layer: glossy_bsdf,
                base: df::diffuse_reflection_bsdf(
                    roughness: 0.0,
                    tint: diffuse_color
                ),
                normal: normal
            )
        )
    )
);

export material scratched_metal(
    color metal_color = color(.9)
    [[
        anno::display_name("Color"),
        anno::description("The color of the metal")
    ]],
    float roughness = 0.05
    [[
        anno::display_name("Roughness"),
        anno::hard_range(0.0,1.),
        anno::description("Higher roughness values lead to bigger highlights and blurry reflections")
    ]],
    float glossy_weight = .9
    [[
        anno::display_name("Reflection weight"),
        anno::hard_range(0.0,1.),
        anno::description("Intensity of highlights and glossy reflections and highlights")
    ]],
    float anisotropy = 0.0
    [[
        anno::display_name("Anisotropy"),
        anno::hard_range(0.0,1.),
        anno::description("Higher values will stretch the highlight")
    ]],
    float anisotropy_rotation = 0.0
    [[
        anno::display_name("Anisotropy rotation"),
        anno::hard_range(0.0,1.),
        anno::description("Changes the orientation of the anisotropy. A value of 1 will rotate the orientation 360 degrees.")
    ]],
    float3 normal = state::normal()
    [[
        anno::display_name("Bumps"),
        anno::description("Attach bump or normal maps here")
    ]]
)
[[
    anno::display_name("Metal , deprecated"),
    anno::description("A metallic material with stretched reflections"),
    anno::thumbnail(".thumbs/scratched_metal.png"),
    anno::hidden(),
    //anno::deprecated("Use scratched_metal_v2 instead"),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(simple_material),
    anno::key_words(string[]("generic","metal"))
]]
 = let{
    base::anisotropy_return anisotropy_values = base::anisotropy_conversion(
        roughness: roughness,
        anisotropy: anisotropy,
        anisotropy_rotation: anisotropy_rotation
    );
    bsdf glossy_bsdf = df::simple_glossy_bsdf(
        mode: df::scatter_reflect,
        tint: metal_color,
        roughness_u: anisotropy_values.roughness_u,
        roughness_v: anisotropy_values.roughness_v,
        tangent_u: anisotropy_values.tangent_u
    );
} in material(
    thin_walled: true,
    surface: material_surface(
        scattering: df::weighted_layer(
            weight: 1.,
            normal: normal,
            layer: df::weighted_layer(
                weight: glossy_weight,
                layer: glossy_bsdf,
                base: df::diffuse_reflection_bsdf(
                    roughness: 0.0,
                    tint: metal_color
                ),
                normal: normal
            )
        )
    )
);

export material scratched_plastic(
    color diffuse_color = color(.5)
    [[
        anno::display_name("Color"),
        anno::description("The color of the material"),
        anno::ui_order(1)
    ]],
    float roughness = 0.05
    [[
        anno::display_name("Roughness"),
        anno::hard_range(0.0,1.),
        anno::description("Higher roughness values lead to bigger highlights and blurry reflections"),
        anno::ui_order(2)
    ]],
    float anisotropy = 0.0
    [[
        anno::display_name("Anisotropy"),
        anno::hard_range(0.0,1.),
        anno::description("Higher values will stretch the highlight"),
        anno::ui_order(4)
    ]],
    float anisotropy_rotation = 0.0
    [[
        anno::display_name("Anisotropy rotation"),
        anno::hard_range(0.0,1.),
        anno::description("Changes the orientation of the anisotropy. A value of 1 will rotate the orientation 360 degrees."),
        anno::ui_order(5)
    ]],
    uniform float ior = 1.4
    [[
        anno::display_name("IOR"),
        anno::soft_range(1.0,4.0),
        anno::description("Determines reflectivity"),
        anno::ui_order(6)
    ]],
    float reflectivity = 1.
    [[
        anno::display_name("Reflection weight"),
        anno::hard_range(0.0,1.),
        anno::description("Additional Reflectivity control"),
        anno::ui_order(3)
    ]],
    float3 normal = state::normal()
    [[
        anno::display_name("Bumps"),
        anno::description("Attach bump or normal maps here"),
        anno::ui_order(7)
    ]]
)
[[
    anno::display_name("Plastic, deprecated"),
    anno::description("A basic dielectric, works for everything opaque that is not metallic. Supports stretched highlights."),
    anno::thumbnail(".thumbs/scratched_plastic.png"),
    anno::hidden(),
    //anno::deprecated("Use scratched_plastic_v2 instead"),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(simple_material),
    anno::key_words(string[]("generic","dielectric","plastic","wood","stone"))
]]
 = let{
    base::anisotropy_return anisotropy_values = base::anisotropy_conversion(
        roughness: roughness,
        anisotropy: anisotropy,
        anisotropy_rotation: anisotropy_rotation
    );
    bsdf glossy_bsdf = df::simple_glossy_bsdf(
        mode: df::scatter_reflect,
        tint: color(1.),
        roughness_u: anisotropy_values.roughness_u,
        roughness_v: anisotropy_values.roughness_v,
        tangent_u: anisotropy_values.tangent_u
    );
} in material(
    thin_walled: true,
    surface: material_surface(
        scattering: df::weighted_layer(
            weight: 1.,
            normal: normal,
            layer: df::fresnel_layer(
                ior: ior,
                weight: reflectivity,
                layer: glossy_bsdf,
                base: df::diffuse_reflection_bsdf(
                    roughness: 0.0,
                    tint: diffuse_color
                ),
                normal: normal
            )
        )
    )
);

export material apply_colorfalloff(
    material base = scratched_metal(metal_color: color(1.))
    [[
        anno::display_name("Base material"),
        anno::description("The material that will get a clear coating applied")
    ]],
    color color_0 = color(1.,0.,0.)
    [[
        anno::display_name("Color 1"),
        anno::description("The color of the dust")
    ]],
    color color_1 = color(0.,1.,0.)
    [[
        anno::display_name("Color 2"),
        anno::description("The color of the dust")
    ]],
    color color_2 = color(0.,0.,1.)
    [[
        anno::display_name("Color 3"),
        anno::description("The color of the dust")
    ]],
    color color_3 = color(1.,0.,0.)
    [[
        anno::display_name("Color 4"),
        anno::description("The color of the dust")
    ]],
    color color_4 = color(0.,1.,0.)
    [[
        anno::display_name("Color 5"),
        anno::description("The color of the dust")
    ]]
)
[[
    anno::display_name("Apply a color falloff, deprecated"),
    anno::description("Makes the color view dependent"),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT),
    anno::thumbnail(".thumbs/apply_colorfalloff.png"),
    anno::hidden(),
    //anno::deprecated("Use apply_colorfalloff_v2 instead"),
    type_of_material(modifier_material),
    anno::key_words(string[]("modifier","generic","coating"))
]]
 =  material(
    surface: material_surface(
        scattering: df::measured_curve_factor(
            curve_values: color[](color_0,color_1,color_2,color_3,color_4),
            base: base.surface.scattering
        ),
        emission: base.surface.emission
    ),
    volume: base.volume,
    ior: base.ior,
    thin_walled: base.thin_walled,
    geometry: base.geometry
);

export material flex_material(
    color base_color = color(.5)
    [[
        anno::display_name("Base color"),
        anno::in_group("Base"),
        anno::description("The color of the material"),
        anno::ui_order(1)
    ]],
    float diffuse_roughness = 0.0
    [[
        anno::display_name("Diffuse roughness"),
        anno::in_group("Base"),
        anno::hard_range(0.0,1.),
        anno::description("Higher roughness values lead to a more \"powdery\" look"),
        anno::ui_order(2)
    ]],
    uniform bool is_metal = false
    [[
        anno::display_name("Metallic material"),
        anno::in_group("Base"),
        anno::description("If true, reflection will be colored and independent of view direction. If false, reflection will be white and direction dependent. Directional dependence is in this case based on the IOR (Fresnel effect)."),
        anno::ui_order(3)
    ]],
    float reflectivity = 1.0
    [[
        anno::display_name("Reflection weight"),
        anno::in_group("Base"),
        anno::hard_range(0.0,1.),
        anno::description("Controls the amount of reflection"),
        anno::ui_order(5)
    ]],
    float reflection_roughness = 0.1
    [[
        anno::display_name("Reflection roughness"),
        anno::in_group("Base"),
        anno::hard_range(0.0,1.),
        anno::description("Higher roughness values lead to more blurry reflections"),
        anno::ui_order(4)
    ]],
    float anisotropy = 0.0
    [[
        anno::display_name("Reflection anisotropy"),
        anno::in_group("Base"),
        anno::hard_range(0.0,1.),
        anno::description("Higher values will stretch the highlight"),
        anno::ui_order(6)
    ]],
    float anisotropy_rotation = 0.0
    [[
        anno::display_name("Anisotropy rotation"),
        anno::in_group("Base"),
        anno::hard_range(0.0,1.),
        anno::description("Changes the orientation of the anisotropy. A value of 1 will rotate the orientation 360 degrees."),
        anno::ui_order(7)
    ]],
    float transparency = 0.0
    [[
        anno::display_name("Transmission weight"),
        anno::in_group("Transmission"),
        anno::hard_range(0.0,1.),
        anno::description("Weights how much light passes through the object vs. its diffuse reflectivity"),
        anno::ui_order(12)
    ]],
    color transmission_color = color(1.)
    [[
        anno::display_name("Transmission color"),
        anno::in_group("Transmission"),
        anno::description("Color effect for transmission independent of thickness of the object, similar to stained glass"),
        anno::ui_order(8)
    ]],
    uniform color volume_color = color(1.0)
    [[
        anno::display_name("Volume color"),
        anno::in_group("Transmission"),
        anno::description("If the material is not \"Thin walled\", \"Volume color\" will be reached at \"Volume reference distance\"(m)"),
        anno::ui_order(9)
    ]],
    float transmission_roughness = 0.0
    [[
        anno::display_name("Transmission roughness"),
        anno::in_group("Transmission"),
        anno::hard_range(0.0,1.),
        anno::description("higher values lead to objects seen through the material to appear blurry"),
        anno::ui_order(11)
    ]],
    uniform float base_thickness = 0.1
    [[
        anno::display_name("Volume reference distance"),
        anno::in_group("Transmission"),
        anno::soft_range(0.0,10.0),
        anno::description("If the material is not \"Thin walled\", \"Volume color\" will be reached at this distance (m). Enter a typical thickness of objects made of this material here."),
        anno::ui_order(10)
    ]],
    uniform float ior = 1.5
    [[
        anno::display_name("IOR"),
        anno::in_group("Global"),
        anno::soft_range(1.0,4.0),
        anno::description("Determines refraction in the volume. It also influences the reflectivity for materials that are not metallic."),
        anno::ui_order(14)
    ]],
    uniform bool thin_walled = false
    [[
        anno::display_name("Thin walled"),
        anno::in_group("Global"),
        anno::description("Thin walled materials do not refract and do not have volume effects. Good for soap bubbles or window glass."),
        anno::ui_order(13)
    ]],
    float3 normal = state::normal()
    [[
        anno::display_name("Bumps"),
        anno::in_group("Global"),
        anno::description("Attach bump or normal maps here"),
        anno::ui_order(16)
    ]],
    uniform float abbe_number = 0.0
    [[
        anno::in_group("Global"),
        anno::display_name("Abbe number"),
        anno::description("Controls dispersion. A value of 0 switches dispersion off, Dispersive materials have Abbe numbers between 25 and 85."),
        anno::soft_range(0.0,100.0),
        anno::ui_order(15)
    ]]
)
[[
    anno::display_name("Flexible material model, deprecated"),
    anno::description("A complex material that can be configured to a wide variety of looks"),
    anno::thumbnail(".thumbs/flex_material.png"),
    anno::hidden(),
    //anno::deprecated("Use flex_material_v2 instead"),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(complex_material),
    anno::key_words(string[]("generic","complex"))
]]
 = let{
    base::anisotropy_return anisotropy_values = base::anisotropy_conversion(
        roughness: reflection_roughness,
        anisotropy: anisotropy,
        anisotropy_rotation: anisotropy_rotation
    );
    bsdf glossy_bsdf = df::simple_glossy_bsdf(
        mode: df::scatter_reflect,
        tint: is_metal? base_color: color(1.),
        roughness_u: anisotropy_values.roughness_u,
        roughness_v: anisotropy_values.roughness_v,
        tangent_u: anisotropy_values.tangent_u
    );
    bsdf diffuse_bsdf = df::diffuse_reflection_bsdf(
        tint: base_color,
        roughness: diffuse_roughness
    );
    bsdf transmission_bsdf = df::simple_glossy_bsdf(
        mode: df::scatter_transmit,
        tint: transmission_color,
        roughness_u: transmission_roughness
    );
    bsdf add_transparency = df::weighted_layer(
        weight: transparency,
        layer: transmission_bsdf,
        base: diffuse_bsdf,
        normal: normal
    );
    bsdf add_reflection = is_metal? df::weighted_layer(
        weight: reflectivity,
        layer: glossy_bsdf,
        base: add_transparency,
        normal: normal
    ): df::fresnel_layer(
        ior: ior,
        weight: reflectivity,
        layer: glossy_bsdf,
        base: add_transparency,
        normal: normal
    );
    bsdf add_normal = df::weighted_layer(
        normal: normal,
        weight: 1.,
        layer: add_reflection
    );
} in material(
    thin_walled: thin_walled,
    ior: abbe_number == 0.0?color(ior):base::abbe_number_ior(ior, abbe_number),
    surface: material_surface(
        scattering: add_normal
    ),
    volume: material_volume(
        absorption_coefficient: (base_thickness <= 0)? color(0): math::log(volume_color) / -base_thickness
    )
);

export material thin_glass(
    color glass_color = color(.95)
    [[
        anno::display_name("Transmission color"),
        anno::description("The color of the material")
    ]],
    float roughness = 0.0
    [[
        anno::display_name("Roughness"),
        anno::hard_range(0.0,1.),
        anno::description("Higher roughness values lead to bigger highlights and blurry reflections")
    ]],
    uniform float ior = 1.4
    [[
        anno::display_name("IOR"),
        anno::soft_range(1.0,4.0),
        anno::description("Determines reflectivity")
    ]],
    float3 normal = state::normal()
    [[
        anno::display_name("Bumps"),
        anno::description("Attach bump or normal maps here")
    ]]
)
[[
    anno::display_name("Thin glass, deprecated"),
    anno::description("A basic transmissive dielectric without refraction or volume"),
    anno::thumbnail(".thumbs/thin_glass.png"),
    anno::hidden(),
    //anno::deprecated("Use thin_glass_v2 instead"),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(simple_material),
    anno::key_words(string[]("generic","dielectric","glass"))
]]
 = let{
    bsdf glossy_reflection_bsdf = df::simple_glossy_bsdf(
        mode: df::scatter_reflect,
        tint: color(1.),
        roughness_u: roughness
    );
    bsdf glossy_transmission_bsdf = df::simple_glossy_bsdf(
        mode: df::scatter_transmit,
        tint: glass_color,
        roughness_u: roughness
    );
} in material(
    thin_walled: true,
    surface: material_surface(
        df::fresnel_layer(
            ior: ior,
            normal: normal,
            layer: glossy_reflection_bsdf,
            base: df::weighted_layer(
                layer: glossy_transmission_bsdf,
                normal: normal,
                weight: 1.
            )
        )
    )
);

export material thin_translucent(
    color surface_color = color(.95)
    [[
        anno::display_name("Diffuse color"),
        anno::description("The color of the material")
    ]],
    color translucent_color = color(.95)
    [[
        anno::display_name("Translucence color"),
        anno::description("The color of the volume of the material")
    ]],
    float translucency = 0.5
    [[
        anno::display_name("Translucence weight"),
        anno::hard_range(0.0,1.),
        anno::description("Fraction of the incoming light that should be visible on the backside")
    ]],
    float roughness = 0.0
    [[
        anno::display_name("Roughness"),
        anno::hard_range(0.0,1.),
        anno::description("Higher roughness values lead to bigger highlights and blurry reflections")
    ]],
    uniform float ior = 1.4
    [[
        anno::display_name("IOR"),
        anno::soft_range(1.0,4.0),
        anno::description("Determines reflectivity")
    ]],
    float3 normal = state::normal()
    [[
        anno::display_name("Bumps"),
        anno::description("Attach bump or normal maps here")
    ]]
)
[[
    anno::display_name("Thin translucent, deprecated"),
    anno::description("A diffuse transmissive dielectric material"),
    anno::thumbnail(".thumbs/thin_translucent.png"),
    anno::hidden(),
    //anno::deprecated("Use thin_translucent_v2 instead"),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(simple_material),
    anno::key_words(string[]("generic","dielectric","leaves","paper","sheets"))
]]
 = let{
    bsdf glossy_reflection_bsdf = df::simple_glossy_bsdf(
        mode: df::scatter_reflect,
        tint: color(1.),
        roughness_u: roughness
    );
    bsdf transmission_bsdf = df::diffuse_transmission_bsdf(
        tint: translucent_color
    );
    bsdf base_bsdf = df::diffuse_reflection_bsdf(
        tint: surface_color
    );
} in material(
    thin_walled: true,
    surface: material_surface(
        df::fresnel_layer(
            ior: ior,
            normal: normal,
            layer: glossy_reflection_bsdf,
            base: df::weighted_layer(
                weight: translucency,
                normal: normal,
                base: base_bsdf,
                layer: df::weighted_layer(
                    layer: transmission_bsdf,
                    normal: normal,
                    weight: 1.
                )
            )
        )
    )
);

export material thick_glass(
    color transmission_color = color(1.0)
    [[
        anno::ui_order(1),
        anno::display_name("Transmission color"),
        anno::description("Colors the light entering the volume, similar to stained glass")
    ]],
    uniform color glass_color = color(.95)
    [[
        anno::ui_order(2),
        anno::display_name("Volume color"),
        anno::description("The color of the glass body")
    ]],
    float roughness = 0.0
    [[
        anno::ui_order(4),
        anno::display_name("Roughness"),
        anno::hard_range(0.0,1.),
        anno::description("Higher roughness values lead to bigger highlights and blurry reflections")
    ]],
    uniform float ior = 1.4
    [[
        anno::ui_order(5),
        anno::display_name("IOR"),
        anno::soft_range(1.0,4.0),
        anno::description("Determines reflectivity as well as amount of refraction")
    ]],
    uniform float base_thickness = .1
    [[
        anno::ui_order(3),
        anno::display_name("Volume reference distance"),
        anno::soft_range(0.0,10.0),
        anno::description("\"Volume color\" will be reached at this distance (m). Enter a typical thickness of objects made of this material here.")

    ]],
    float3 normal = state::normal()
    [[
        anno::ui_order(7),
        anno::display_name("Bumps"),
        anno::description("Attach bump or normal maps here")
    ]],
    uniform float abbe_number = 0.0
    [[
        anno::ui_order(6),
        anno::display_name("Abbe number"),
        anno::description("Controls dispersion. A value of 0 switches dispersion off. Dispersive materials have Abbe numbers between 25 and 85."),
        anno::soft_range(0.0,100.0)
    ]]
)
[[
    anno::display_name("Thick glass, deprecated"),
    anno::description("A basic transmissive dielectric with refraction and coloring in the volume"),
    anno::thumbnail(".thumbs/thick_glass.png"),
    anno::hidden(),
    //anno::deprecated("Use thick_glass_v2 instead"),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(simple_material),
    anno::key_words(string[]("generic","dielectric","glass"))
]]
 = let{
    bsdf glossy_bsdf = df::simple_glossy_bsdf(
        mode: df::scatter_reflect,
        tint: color(1.),
        roughness_u: roughness
    );
    bsdf glossy_bsdf_transmission = df::simple_glossy_bsdf(
        mode: df::scatter_transmit,
        tint: transmission_color,
        roughness_u: roughness
    );
} in material(
    thin_walled: false,
    surface: material_surface(
        df::weighted_layer(
            normal: normal,
            weight: 1.,
            layer: df::fresnel_layer(
                layer: glossy_bsdf,
                base: glossy_bsdf_transmission,
                ior: ior,
                normal: normal
            )
        )
    ),
    volume: material_volume(
        absorption_coefficient: (base_thickness <= 0)? color(0): math::log(glass_color) / -base_thickness
    ),
    ior: abbe_number == 0.0?color(ior):base::abbe_number_ior(ior, abbe_number)
);

export material thick_translucent(
    color transmission_color = color(.95)
    [[
        anno::display_name("Transmission color"),
        anno::description("The color of the material"),
        anno::ui_order(1)
    ]],
    uniform color volume_color = color(.95)
    [[
        anno::display_name("Volume color"),
        anno::description("The color of the volume at \"Volume reference distance\""),
        anno::ui_order(2)
    ]],
    uniform float volume_scattering = 0.5
    [[
        anno::display_name("Volume scattering"),
        anno::hard_range(0.0,.99999),
        anno::description("Amount of scattering for objects at \"Volume reference distance\""),
        anno::ui_order(3)
    ]],
    float roughness = 0.0
    [[
        anno::display_name("Reflection roughness"),
        anno::hard_range(0.0,1.),
        anno::description("Higher roughness values lead to bigger highlights and blurry reflections"),
        anno::ui_order(5)
    ]],
    float reflectivity = 1.
    [[
        anno::display_name("Reflection weight"),
        anno::hard_range(0.0,1.),
        anno::description("Overall reflectivity of the material"),
        anno::ui_order(6)
    ]],
    uniform float base_thickness = .1
    [[
        anno::display_name("Volume reference distance"),
        anno::soft_range(0.0,10.0),
        anno::description("\"Volume color\" and \"Volume scattering\" will be reached at this distance (m). Enter a typical thickness of objects made of this material here."),
        anno::ui_order(4)

    ]],
    float3 normal = state::normal()
    [[
        anno::display_name("Bumps"),
        anno::description("Attach bump or normal maps here"),
        anno::ui_order(9)
    ]],
    uniform float ior = 1.4
    [[
        anno::display_name("IOR"),
        anno::soft_range(1.0,4.0),
        anno::description("Determines reflectivity as well as amount of refraction"),
        anno::ui_order(7)
    ]],
    uniform float abbe_number = 0.0
    [[
        anno::display_name("Abbe number"),
        anno::description("Controls dispersion. A value of 0switches dispersion off. Dispersive materials have Abbe numbers between 25 and 85."),
        anno::soft_range(0.0,100.0),
        anno::ui_order(8)
    ]]
)
[[
    anno::display_name("Thick translucent, deprecated"),
    anno::description("A subsurface scattering material"),
    anno::thumbnail(".thumbs/thick_translucent.png"),
    anno::hidden(),
    //anno::deprecated("Use thick_translucent_v2 instead"),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(simple_material),
    anno::key_words(string[]("generic","dielectric","wax","milk"))
]]
 = let{
    bsdf glossy_bsdf = df::simple_glossy_bsdf(
        mode: df::scatter_reflect,
        tint: color(1.),
        roughness_u: roughness
    );
    bsdf transmission_bsdf = df::specular_bsdf(
        mode: df::scatter_transmit,
        tint: transmission_color
    );

} in material(
    thin_walled: false,
    surface: material_surface(
        df::fresnel_layer(
            normal: normal,
            weight: reflectivity,
            ior: ior,
            layer: glossy_bsdf,
            base: df::weighted_layer(
                normal: normal,
                weight: 1.,
                layer: transmission_bsdf
            )
        )
    ),
    volume: material_volume(
        scattering_coefficient: (base_thickness <= 0)? color(0): math::log(color(1.-volume_scattering)) / - base_thickness,
        absorption_coefficient: (base_thickness <= 0)? color(0): math::log(volume_color) / -base_thickness
    ),
    ior: abbe_number == 0.0?color(ior):base::abbe_number_ior(ior, abbe_number)
);

export material apply_clearcoat(
    material base = diffuse(diffuse_color: color(0.))
    [[
        anno::display_name("Base material"),
        anno::description("The material that will get a clear coating applied"),
        anno::ui_order(1)
    ]],
    uniform float ior = 1.6
    [[
        anno::display_name("IOR"),
        anno::soft_range(1.0,4.0),
        anno::description("Determines reflectivity of the clear coat"),
        anno::ui_order(5)
    ]],
    float roughness = 0.0
    [[
        anno::display_name("Reflection roughness"),
        anno::hard_range(0.0,1.0),
        anno::description("Determines roughness of the clear coat"),
        anno::ui_order(3)
    ]],
    float visibility = 1.0
    [[
        anno::display_name("Coat visibility"),
        anno::hard_range(0.0,1.0),
        anno::description("Determines visibility of the clear coat"),
        anno::ui_order(4)
    ]],
    float3 normal = state::normal()
    [[
        anno::display_name("Bumps"),
        anno::description("Attach bump or normal maps here"),
        anno::ui_order(6)
    ]],
    color coat_filter_color = color(1.)
    [[
        anno::display_name("Coat filter color"),
        anno::description("For simulating coatings with colored resins that modulate the color of underlying layers"),
        anno::ui_order(2)
    ]]
)
[[
    anno::display_name("Apply clear coating, deprecated"),
    anno::description("Apply clear coat to an existing material"),
    anno::author("NVIDIA Corporation"),
    anno::thumbnail(".thumbs/apply_clearcoat.png"),
    anno::hidden(),
    //anno::deprecated("Use apply_clearcoat_v2 instead"),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(modifier_material),
    anno::key_words(string[]("modifier","generic","coating"))
]]
 = let{
    bsdf glossy_bsdf = df::simple_glossy_bsdf(
        mode: df::scatter_reflect,
        roughness_u: roughness,
        tint: color(1.)
    );
    color base_tint = blend_colors(color(1.), coat_filter_color, color_layer_blend, visibility).tint;
} in material(
    surface: material_surface(
        scattering: df::fresnel_layer(
            ior: ior,
            normal: normal,
            weight: visibility,
            layer: glossy_bsdf,
            base: df::tint(tint: base_tint, base: base.surface.scattering)
        ),
        emission: base.surface.emission
    ),
    volume: base.volume,
    ior: base.ior,
    thin_walled: base.thin_walled,
    geometry: base.geometry
);

export material apply_metalcoat(
    material base = diffuse(diffuse_color: color(0.))
    [[
        anno::display_name("Base material"),
        anno::description("The material that will get a metallic coating applied"),
        anno::ui_order(1)
    ]],
    color metal_color = color(.95)
    [[
        anno::display_name("Reflection color"),
        anno::description("The color of the metal"),
        anno::ui_order(2)
    ]],
    float visibility = .3
    [[
        anno::display_name("Reflection weight"),
        anno::hard_range(0.0,1.0),
        anno::description("The opacity of the coat"),
        anno::ui_order(4)
    ]],
    float roughness = 0.0
    [[
        anno::display_name("Reflection roughness"),
        anno::hard_range(0.0,1.0),
        anno::description("Determines roughness of the metal coat"),
        anno::ui_order(3)
    ]],
    float3 normal = state::normal()
    [[
        anno::display_name("Bumps"),
        anno::description("Attach bump or normal maps here"),
        anno::ui_order(5)
    ]]
)
[[
    anno::display_name("Apply thin metal coating, deprecated"),
    anno::description("Apply metal coat to an existing material"),
    anno::thumbnail(".thumbs/apply_metalcoat.png"),
    anno::hidden(),
    //anno::deprecated("Use apply_metalcoat_v2 instead"),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT),
    type_of_material(modifier_material),
    anno::key_words(string[]("modifier","generic","coating"))
]]
 = let{
    bsdf glossy_bsdf = df::simple_glossy_bsdf(
        mode: df::scatter_reflect,
        roughness_u: roughness,
        tint: metal_color
    );
} in material(
    surface: material_surface(
        scattering: df::weighted_layer(
            weight: visibility,
            normal: normal,
            layer: glossy_bsdf,
            base: base.surface.scattering
        ),
        emission: base.surface.emission
    ),
    volume: base.volume,
    ior: base.ior,
    thin_walled: base.thin_walled,
    geometry: base.geometry
);

//endgroup

/*-**/
