/******************************************************************************
 * Copyright (c) 2022-2025, NVIDIA CORPORATION. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  * Neither the name of NVIDIA CORPORATION nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

rules Complex_alias bottomup {
    import state;
    import math;

    material( tw,
              material_surface(_,_) [[ local_normal ~ nl ]],
              bf,ior,vol,
              material_geometry(d,cutout,n), hair)
        --> material(tw,material_surface(),bf,ior,vol,material_geometry(d,cutout,nprime),hair)
        maybe n != nl
        where nprime = nvidia::distilling_support::add_detail_normal( nl, n);
    a ~ bsdf() --> a [[ local_normal_w = 0.0, local_normal=state::normal() ]];

    a ~ diffuse_reflection_bsdf(_,_) --> a [[ local_normal_w = 0.0, local_normal=state::normal() ]];

    // diffuse_transmission_bsdf(_) --> local_normal(0.0,state::normal());
    // specular_bsdf(_) --> local_normal(0.0,state::normal());
    // simple_glossy_bsdf(_,_,_,_,_) --> local_normal(0.0,state::normal());
    // // bsdf_tint(_,base) --> base;
    // // bsdf_tint_ex(_,_,base) --> base;
    // bsdf_mix_1(w1, local_normal(nw,nl)) --> local_normal( w1 * nw, nl);
    // bsdf_color_mix_1(w1, local_normal(nw,nl))
    //     --> local_normal( math::luminance(w1) * nw, nl);
    // bsdf_mix_2(w1,local_normal(nw1,nl1),w2,local_normal(nw2,nl2))
    //     --> local_normal( w1 * nw1 + w2 * nw2, nl1)
    //     if nl1 == nl2;
    // bsdf_mix_2(w1,local_normal(nw1,nl1),w2,local_normal(nw2,nl2))
    //     --> local_normal( w1 * nw1 + w2 * nw2,
    //             nvidia::distilling_support::affine_normal_sum( w1 * nw1, nl1, w2 * nw2, nl2));
    // bsdf_color_mix_2(w1,local_normal(nw1,nl1),w2,local_normal(nw2,nl2))
    //     --> local_normal( math::luminance(w1) * nw1 + math::luminance(w2) * nw2, nl1)
    //     if nl1 == nl2;
    // bsdf_color_mix_2(w1,local_normal(nw1,nl1),w2,local_normal(nw2,nl2))
    //     --> local_normal( w1p * nw1 + w2p * nw2,
    //             nvidia::distilling_support::affine_normal_sum( w1p * nw1, nl1, w2p * nw2, nl2))
    //     where w1p = math::luminance(w1)
    //           w2p = math::luminance(w2);
    // bsdf_mix_3(w1,local_normal(nw1,nl1),
    //            w2,local_normal(nw2,nl2),
    //            w3,local_normal(nw3,nl3))
    //     --> local_normal( w1 * nw1 + w2 * nw2 + w3 * nw3, nl1)
    //     if (nl1 == nl2) && (nl1 == nl3);
    // bsdf_mix_3(w1,local_normal(nw1,nl1),
    //            w2,local_normal(nw2,nl2),
    //            w3,local_normal(nw3,nl3))
    //      --> local_normal( w1 * nw1 + w2 * nw2 + w3 * nw3,
    //              nvidia::distilling_support::affine_normal_sum(
    //                  w1 * nw1, nl1, w2 * nw2, nl2, w3 * nw3, nl3));
    // bsdf_color_mix_3(w1,local_normal(nw1,nl1),
    //                  w2,local_normal(nw2,nl2),
    //                  w3,local_normal(nw3,nl3))
    //     --> local_normal( math::luminance(w1) * nw1 + math::luminance(w2) * nw2
    //                                    + math::luminance(w3) * nw3, nl1)
    //     if (nl1 == nl2) && (nl1 == nl3);
    // bsdf_color_mix_3(w1,local_normal(nw1,nl1),
    //            w2,local_normal(nw2,nl2),
    //            w3,local_normal(nw3,nl3))
    //      --> local_normal( w1p * nw1 + w2p * nw2 + w3p * nw3,
    //              nvidia::distilling_support::affine_normal_sum(
    //                  w1p * nw1, nl1, w2p * nw2, nl2, w3p * nw3, nl3))
    //     where w1p = math::luminance(w1)
    //           w2p = math::luminance(w2)
    //           w3p = math::luminance(w3);
    // weighted_layer(w,local_normal(_,nl1),local_normal(nw2,nl2),n)
    //     --> local_normal( nw2 * (1.0-w) + w, n)
    //     if (n == nl1) && (n == nl2);
    // weighted_layer(w,local_normal(nw1,nl1),local_normal(nw2,nl2),n)
    //     --> local_normal( nw2 * (1.0-w) + w,
    //             nvidia::distilling_support::affine_normal_sum(
    //                 (1.0-w)*nw2, nl2, w*(1.0-nw1), n, w*nw1, nl1));
    // color_weighted_layer(w,local_normal(_,nl1),local_normal(nw2,nl2),n)
    //     --> local_normal( nw2 * (1.0-math::luminance(w)) + math::luminance(w), n)
    //     if (n == nl1) && (n == nl2);
    // color_weighted_layer(w,local_normal(nw1,nl1),local_normal(nw2,nl2),n)
    //     --> local_normal( nw2 * (1.0-wp) + wp,
    //             nvidia::distilling_support::affine_normal_sum(
    //                 (1.0-wp)*nw2, nl2, wp*(1.0-nw1), n, wp*nw1, nl1))
    //     where wp = math::luminance(w);
    // fresnel_layer(_,w0,local_normal(_,nl1),local_normal(nw2,nl2),n)
    //     --> local_normal( nw2 * (1.0-w) + w, n)
    //     if (n == nl1) && (n == nl2)
    //     where w = w0 * option( top_layer_weight);
    // fresnel_layer(_,w0,local_normal(nw1,nl1),
    //                    local_normal(nw2,nl2),n)
    //     --> local_normal( nw2 * (1.0-w) + w,
    //             nvidia::distilling_support::affine_normal_sum(
    //                 (1.0-w)*nw2, nl2, w*(1.0-nw1), n, w*nw1, nl1))
    //     where w = w0 * option( top_layer_weight);
    // color_fresnel_layer(_,w0,local_normal(_,nl1),local_normal(nw2,nl2),n)
    //     --> local_normal( nw2 * (1.0-w) + w, n)
    //     if (n == nl1) && (n == nl2)
    //                       where w = math::luminance(w0) * option( top_layer_weight);
    // color_fresnel_layer(_,w0,local_normal(nw1,nl1),
    //                          local_normal(nw2,nl2),n)
    //     --> local_normal( nw2 * (1.0-w) + w,
    //             nvidia::distilling_support::affine_normal_sum(
    //                 (1.0-w)*nw2, nl2, w*(1.0-nw1), n, w*nw1, nl1))
    //     where w = math::luminance(w0) * option( top_layer_weight);
}
