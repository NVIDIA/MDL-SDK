/*-------------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------
  Trace output options
  0 | A: prints the states of the scanner automaton
  1 | F: prints the First and Follow sets of all nonterminals
  2 | G: prints the syntax graph of the productions
  3 | I: traces the computation of the First sets
  4 | J: prints the sets associated with ANYs and synchronisation sets
  6 | S: prints the symbol table (terminals, nonterminals, pragmas)
  7 | X: prints a cross reference list of all syntax symbols
  8 | P: prints statistics about the Coco run

  Trace output can be switched on by the pragma
    $ { digit | letter }
  in the attributed grammar or as a command-line option
  -------------------------------------------------------------------------*/


#include <stdio.h>
#include "Scanner.h"
#include "Parser.h"
#include "Tab.h"

using namespace Coco;

int main(int argc, char *argv[]) {

	printf("Coco/R (Mar 22, 2023, NVidia modified)\n");

	char *srcName = NULL;
	char *nsName = NULL;
	char *tokenPrefix = NULL;
	char *frameDir = NULL;
	char *ddtString = NULL;
	char *traceFileName = NULL;
	char *outDir = NULL;
	bool emitLines = false;
	bool suppressRslvWarning = false;

	for (int i = 1; i < argc; i++) {
		if (coco_string_equal(argv[i], "-namespace") && i < argc - 1) nsName = coco_string_create(argv[++i]);
		else if (coco_string_equal(argv[i], "-token_prefix") && i < argc - 1) tokenPrefix = coco_string_create(argv[++i]);
		else if (coco_string_equal(argv[i], "-frames") && i < argc - 1) frameDir = coco_string_create(argv[++i]);
		else if (coco_string_equal(argv[i], "-trace") && i < argc - 1) ddtString = coco_string_create(argv[++i]);
		else if (coco_string_equal(argv[i], "-o") && i < argc - 1) outDir = coco_string_create_append(argv[++i], "/");
		else if (coco_string_equal(argv[i], "-lines")) emitLines = true;
		else if (coco_string_equal(argv[i], "-no_misplaced_resolver")) suppressRslvWarning = true;
		else srcName = coco_string_create(argv[i]);
	}

	if (argc > 0 && srcName != NULL) {
		int pos = coco_string_lastindexof(srcName, '/');
		if (pos < 0) pos = coco_string_lastindexof(srcName, '\\');
		char* file = coco_string_create(srcName);
		char* srcDir = coco_string_create(srcName, 0, pos+1);

		Coco::Scanner *scanner = new Coco::Scanner(file);
		Coco::Parser  *parser  = new Coco::Parser(scanner);

		traceFileName = coco_string_create_append(outDir != NULL ? outDir : srcDir, "trace.txt");

		if ((parser->trace = fopen(traceFileName, "w")) == NULL) {
			printf("-- could not open %s\n", traceFileName);
			exit(1);
		}

		parser->tab  = new Coco::Tab(parser);
		parser->dfa  = new Coco::DFA(parser);
		parser->pgen = new Coco::ParserGen(parser);

		parser->tab->srcName  = coco_string_create(srcName);
		parser->tab->srcDir   = coco_string_create(srcDir);
		parser->tab->nsName   = nsName ? coco_string_create(nsName) : NULL;
		parser->tab->tokenPrefix = tokenPrefix ? coco_string_create(tokenPrefix) : coco_string_create("_");
		parser->tab->frameDir = coco_string_create(frameDir);
		parser->tab->outDir   = coco_string_create(outDir != NULL ? outDir : srcDir);
		parser->tab->emitLines = emitLines;
		parser->tab->suppressRslvWarning = suppressRslvWarning;

		parser->errors->srcName = parser->tab->srcName;

		if (ddtString != NULL) parser->tab->SetDDT(ddtString);

		parser->Parse();

		fclose(parser->trace);

		// obtain the FileSize
		parser->trace = fopen(traceFileName, "r");
		fseek(parser->trace, 0, SEEK_END);
		long fileSize = ftell(parser->trace);
		fclose(parser->trace);
		if (fileSize == 0) {
			remove(traceFileName);
		} else {
			printf("trace output is in %s\n", traceFileName);
		}

		printf("%d errors detected\n", parser->errors->count);
		if (parser->errors->count != 0) {
			exit(1);
		}

		delete parser->pgen;
		delete parser->dfa;
		delete parser->tab;
		delete parser;
		delete scanner;
		coco_string_delete(file);
		coco_string_delete(srcDir);
	} else {
		printf("Usage: Coco Grammar.ATG {Option}\n");
		printf("Options:\n");
		printf("  -namespace <namespaceName>\n");
		printf("  -frames    <frameFilesDirectory>\n");
		printf("  -trace     <traceString>\n");
		printf("  -o         <outputDirectory>\n");
		printf("  -lines\n");
		printf("Valid characters in the trace string:\n");
		printf("  A  trace automaton\n");
		printf("  F  list first/follow sets\n");
		printf("  G  print syntax graph\n");
		printf("  I  trace computation of first sets\n");
		printf("  J  list ANY and SYNC sets\n");
		printf("  P  print statistics\n");
		printf("  S  list symbol table\n");
		printf("  X  list cross reference table\n");
		printf("Scanner.frame and Parser.frame files needed in ATG directory\n");
		printf("or in a directory specified in the -frames option.\n");
	}

	coco_string_delete(srcName);
	coco_string_delete(nsName);
	coco_string_delete(tokenPrefix);
	coco_string_delete(frameDir);
	coco_string_delete(ddtString);
	coco_string_delete(traceFileName);

	return 0;
}
