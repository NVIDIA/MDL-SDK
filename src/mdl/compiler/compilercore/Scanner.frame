/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/

/*----------------------------------------------------------------------
Scanner.h Specification
-----------------------------------------------------------------------*/

-->begin

#if !defined(-->prefixCOCO_SCANNER_H__)
#define -->prefixCOCO_SCANNER_H__

#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>

#include <mi/mdl/mdl_streams.h>
#include <mdl/compiler/compilercore/compilercore_errors.h>
#include <mdl/compiler/compilercore/compilercore_memory_arena.h>

#if _MSC_VER >= 1400
#define coco_swprintf swprintf_s
#elif _MSC_VER >= 1300
#define coco_swprintf _snwprintf
#elif defined __MINGW32__
#define coco_swprintf _snwprintf
#else
// assume every other compiler knows swprintf
#define coco_swprintf swprintf
#endif

#define COCO_WCHAR_MAX 65535
#define COCO_MIN_BUFFER_LENGTH 1024
#define COCO_MAX_BUFFER_LENGTH (64*COCO_MIN_BUFFER_LENGTH)
#define COCO_HEAP_BLOCK_SIZE (64*1024)
#define COCO_CPP_NAMESPACE_SEPARATOR L':'

-->namespace_open

// string handling, wide character
unsigned coco_string_hash(const wchar_t* data, size_t len);

// forward
class Error_params;

class Token  
{
public:
	int kind;     // token kind
	int pos;      // token position in bytes in the source text (starting at 0)
	int charPos;  // token position in characters in the source text (starting at 0)
	int col;      // token column (starting at 1)
	int line;     // token line (starting at 1)
	const wchar_t* val; // token value
	Token *next;  // ML 2005-03-11 Peek tokens are kept in linked list

	Token();
};

class Errors {
public:
	int count;			// number of errors detected

	Errors();
	void SynErr(Token const *la, int n);
	virtual void Error(Token const *t, const wchar_t *s);
	virtual void Warning(int line, int col, const wchar_t *s);
	virtual void Warning(const wchar_t *s);
	virtual void Exception(const wchar_t *s);
	virtual void Error(int line, int col, int code, Error_params const &params);

}; // Errors

class Buffer {
private:
	Allocator_builder builder;

	int bufCapacity;    // capacity of buf
	int bufStart;       // position of first byte in buffer relative to input stream
	int bufLen;         // length of buffer
	int fileLen;        // length of input stream (may change if the stream is no file)
	int bufPos;         // current position in buffer
	bool isUserStream;  // was the stream opened by the user?
	IInput_stream *istream; // input stream (non-seekable)
	unsigned char *buf; // input buffer
	
	int ReadNextStreamChunk();
	
public:
	static const int EoF = COCO_WCHAR_MAX + 1;

	Buffer(IAllocator *alloc, IInput_stream* s, bool isUserStream);
	Buffer(Buffer *b);
	virtual ~Buffer();
	
	void Close();
	virtual int Read();
	int Peek();
	int GetPos();
	void SetPos(int value);
};

class UTF8Buffer : public Buffer {
public:
	UTF8Buffer(Buffer *b) : Buffer(b) {};
	virtual int Read();
};

//-----------------------------------------------------------------------------------
// StartStates  -- maps characters to start states of tokens
//-----------------------------------------------------------------------------------
class StartStates {
private:
	class Elem {
	public:
		int key, val;
		Elem *next;

		Elem(int key, int val) : key(key), val(val), next(NULL) {}
	};

	Arena_builder builder;
	Elem *tab[128];

public:
	StartStates(Memory_arena &arena)
		: builder(arena)
	{
		memset(tab, 0, 128 * sizeof(Elem*));
	}

	void set(int key, int val) {
		Elem *e = builder.create<Elem>(key, val);
		int k = key & 127;
		e->next = tab[k]; tab[k] = e;
	}

	int state(int key) {
		Elem *e = tab[key & 127];
		while (e != NULL && e->key != key) e = e->next;
		return e == NULL ? 0 : e->val;
	}
};

//-------------------------------------------------------------------------------------------
// KeywordMap  -- maps strings to integers (identifiers to keyword kinds)
//-------------------------------------------------------------------------------------------
class KeywordMap {
private:
	class Elem {
	public:
		const wchar_t *key;
		size_t len;
		int val;
		Elem *next;
		
		Elem(const wchar_t *key, size_t len, int val)
			: key(key)
			, len(len)
			, val(val)
			, next(NULL)
		{}
	};

	Arena_builder builder;
	Elem *tab[128];

public:
	KeywordMap(Memory_arena &arena)
		: builder(arena)
	{
		memset(tab, 0, 128 * sizeof(Elem*));
	}

	void set(const wchar_t *key, int val) {
		size_t len = wcslen(key);
		Elem *e = builder.create<Elem>(key, len, val);
		unsigned k = coco_string_hash(key, len) & 127;
		e->next = tab[k]; tab[k] = e;
	}

	int get(int len, const wchar_t *key, int defaultVal) {
		const Elem *e = tab[coco_string_hash(key, len) & 127];
		while (e != NULL && (len != e->len || wcsncmp(e->key, key, len) != 0))
			e = e->next;
		return e == NULL ? defaultVal : e->val;
	}

	void change_keyword(const wchar_t *key, int val) {
		size_t len = wcslen(key);
		Elem *e = tab[coco_string_hash(key, len) & 127];
		while (e != NULL && (len != e->len || wcsncmp(e->key, key, len) != 0))
			e = e->next;
		if (e != NULL)
			e->val = val;
	}
};

class Scanner {
protected:
	Memory_arena       arena;
	Arena_builder      arena_builder;
	Allocator_builder  alloc_builder;

	unsigned char EOL;
	int eofSym;
	int noSym;
	int maxT;
	StartStates start;
	KeywordMap keywords;

	Token *t;         // current token
	wchar_t *tval;    // text of current token
	int tvalLength;   // length of text of current token
	int tlen;         // length of current token

	Token *tokens;    // list of tokens already peeked (first token is a dummy)
	Token *pt;        // current peek token
	Errors *errors;   // error handler

	int ch;           // current input character
-->casing0
	int pos;          // byte position of current character
	int charPos;      // position by unicode characters starting with 0
	int line;         // line number of current character
	int col;          // column number of current character
	int oldEols;      // EOLs that appeared in a comment;

	void AppendVal(Token *t);
	void SetScannerBehindT();
	void UndeterminedComment(int line, int col);
	void initialize_mdl_keywords();

	void Init(int start_line, int start_col);
	void NextCh();
	void AddCh();
-->commentsheader
	Token* NextToken();

public:
	Buffer *buffer;   // scanner buffer
	
	Scanner(
		IAllocator *alloc,
		Errors *err,
		mi::mdl::IInput_stream* s,
		int start_line = 1,
		int start_col = 1);
	~Scanner();
	Token* Scan();
	Token* Peek();
	void ResetPeek();
	Token* CreateToken();
	void set_mdl_version(int major, int minor);
	void enable_native_keyword(bool flag);

}; // end Scanner

-->namespace_close

#endif

-->implementation

/*----------------------------------------------------------------------
Scanner.cpp Specification
-----------------------------------------------------------------------*/

-->begin

#include <memory.h>
#include <string.h>
#include "Scanner.h"

-->namespace_open


// string handling, wide character
unsigned coco_string_hash(const wchar_t *data, size_t len) {
	unsigned h = 0;
	if (!data) { return 0; }
	for (size_t i = 0; i < len; ++i) {
		h = (h * 7) ^ unsigned(data[i]);
	}
	return h;
}


Token::Token()
	: kind(0)
	, pos(0)
	, charPos(0)
	, col(0)
	, line(0)
	, val(NULL)
	, next(NULL)
{
}

Buffer::Buffer(IAllocator *alloc, IInput_stream *s, bool isUserStream)
	: builder(alloc)
	, bufCapacity(COCO_MIN_BUFFER_LENGTH)
	, bufStart(0)
	, bufLen(0)
	, fileLen(0)
	, bufPos(0) // index 0 is already after the file, thus Pos = 0 is invalid
	, isUserStream(isUserStream)
	, istream(s)
	, buf(builder.alloc<unsigned char>(bufCapacity))
{
}

Buffer::Buffer(Buffer *b)
	: builder(b->builder.get_allocator())
	, bufCapacity(b->bufCapacity)
	, bufStart(b->bufStart)
	, bufLen(b->bufLen)
	, fileLen(b->fileLen)
	, bufPos(b->bufPos)
	, isUserStream(b->isUserStream)
	, istream(b->istream)
	, buf(b->buf)
{
	b->buf = NULL;
	b->istream = NULL;
}

Buffer::~Buffer() {
	Close();
	if (buf != NULL) {
		builder.free(buf);
		buf = NULL;
	}
}

void Buffer::Close() {
	if (!isUserStream) {
		if (istream != NULL) {
			istream->release();
			istream = NULL;
		}
	}
}

int Buffer::Read() {
	if (bufPos < bufLen) {
		return buf[bufPos++];
	} else if (GetPos() < fileLen) {
		SetPos(GetPos()); // shift buffer start to Pos
		return buf[bufPos++];
	} else if (ReadNextStreamChunk() > 0) {
		return buf[bufPos++];
	} else {
		return EoF;
	}
}

int Buffer::Peek() {
	int curPos = GetPos();
	int ch = Read();
	SetPos(curPos);
	return ch;
}

int Buffer::GetPos() {
	return bufPos + bufStart;
}

void Buffer::SetPos(int value) {
	if ((value < 0) || (value > fileLen)) {
		wprintf(L"--- buffer out of bounds access, position: %d\n", value);
		exit(1);
	}

	if ((value >= bufStart) && (value < (bufStart + bufLen))) { // already in buffer
		bufPos = value - bufStart;
	} else {
		bufPos = fileLen - bufStart; // make Pos return fileLen
	}
}

// Read the next chunk of bytes from the stream, increases the buffer
// if needed and updates the fields fileLen and bufLen.
// Returns the number of bytes read.
int Buffer::ReadNextStreamChunk() {
	int free = bufCapacity - bufLen;
	if (free == 0) {
		// in the case of a growing input stream
		// we can neither seek in the stream, nor can we
		// foresee the maximum length, thus we must adapt
		// the buffer size on demand.
		bufCapacity = bufLen * 2;
		unsigned char *newBuf = builder.alloc<unsigned char>(bufCapacity);
		memcpy(newBuf, buf, bufLen * sizeof(unsigned char));
		builder.free(buf);
		buf = newBuf;
		free = bufLen;
	}
	int read = 0;
	if (istream) {
		for (; read < free; ++read) {
			char c = istream->read_char();
			if (c == -1)
				break;
			buf[bufLen + read] = (unsigned char)c;
		}
	}
	if (read > 0) {
		fileLen = bufLen = (bufLen + read);
		return read;
	}
	// end of stream reached
	return 0;
}

int UTF8Buffer::Read() {
	int ch;
	do {
		ch = Buffer::Read();
		// until we find a utf8 start (0xxxxxxx or 11xxxxxx)
	} while ((ch >= 0x80) && ((ch & 0xC0) != 0xC0) && (ch != EoF));

	if (ch <= 0x7F || ch == EoF) {
		// nothing to do, first 127 chars are the same in ascii and utf8
		// 0xxxxxxx or end of file character
	} else if ((ch & 0xF8) == 0xF0) {
		// 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
		bool error = false;
		int pos = Buffer::GetPos();

		int c1 = ch & 0x07; ch = Buffer::Read(); error |= (ch & 0xC0) != 0x80;
		int c2 = ch & 0x3F; ch = Buffer::Read(); error |= (ch & 0xC0) != 0x80;
		int c3 = ch & 0x3F; ch = Buffer::Read(); error |= (ch & 0xC0) != 0x80;
		int c4 = ch & 0x3F;
		ch = (c1 << 18) | (c2 << 12) | (c3 << 6) | c4;

		// must be U+10000 .. U+10FFFF
		error |= (ch < 0x1000) || (ch > 0x10FFFF);

		if (error) {
			ch = 0xFFFD;  // replacement character
			Buffer::SetPos(pos);
		}
	} else if ((ch & 0xF0) == 0xE0) {
		// 1110xxxx 10xxxxxx 10xxxxxx
		bool error = false;
		int pos = Buffer::GetPos();

		int c1 = ch & 0x0F; ch = Buffer::Read(); error |= (ch & 0xC0) != 0x80;
		int c2 = ch & 0x3F; ch = Buffer::Read(); error |= (ch & 0xC0) != 0x80;
		int c3 = ch & 0x3F;
		ch = (c1 << 12) | (c2 << 6) | c3;

		// must be U+0800 .. U+FFFF
		error |= ch < 0x800;

		if (error) {
			ch = 0xFFFD;  // replacement character
			Buffer::SetPos(pos);
		}
	} else if ((ch & 0xE0) == 0xC0) {
		// 110xxxxx 10xxxxxx
		bool error = false;
		int pos = Buffer::GetPos();

		int c1 = ch & 0x1F; ch = Buffer::Read(); error |= (ch & 0xC0) != 0x80;
		int c2 = ch & 0x3F;
		ch = (c1 << 6) | c2;

		// must be U+0080 .. U+07FF
		error |= ch < 0x80;

		if (error) {
			ch = 0xFFFD;  // replacement character
			Buffer::SetPos(pos);
		}
	} else {
		// error
		ch = 0xFFFD;  // replacement character
	}
	return ch;
}

Scanner::Scanner(
		IAllocator *alloc,
		Errors *err,
		mi::mdl::IInput_stream* s,
		int start_line,
		int start_col)
	: arena(alloc, COCO_HEAP_BLOCK_SIZE)
	, arena_builder(arena)
	, alloc_builder(alloc)
	, start(arena)
	, keywords(arena)
	, t(NULL)
	, tlen(0)
	, errors(err)
{
	buffer = alloc_builder.create<Buffer>(alloc, s, true);
	Init(start_line, start_col);
}

Scanner::~Scanner() {
	alloc_builder.free(tval);
	alloc_builder.destroy(buffer);
}

void Scanner::Init(int start_line, int start_col) {
	// drop the arena
	arena.drop(NULL);

	EOL    = '\n';
	eofSym = 0;
-->declarations

	tvalLength = 128;
	tval = alloc_builder.alloc<wchar_t>(tvalLength); // text of current token

	pos = -1; line = start_line; col = start_col - 1; charPos = -1;
	oldEols = 0;
	NextCh();
	if (ch == 0xEF) { // check optional byte order mark for UTF-8
		NextCh(); int ch1 = ch;
		NextCh(); int ch2 = ch;
		if (ch1 == 0xBB && ch2 == 0xBF) {
			Buffer *oldBuf = buffer;
			buffer = alloc_builder.create<UTF8Buffer>(buffer);
			line = start_line; col = start_col - 1; charPos = -1;
			alloc_builder.destroy(oldBuf);
			NextCh();
		} else {
			errors->Warning(1, 1, L"Illegal byte order mark at start of file ignored");
			buffer->SetPos(0);
		}
	} else {
		// always use UTF-8
		buffer->SetPos(0);
		Buffer *oldBuf = buffer;
		buffer = alloc_builder.create<UTF8Buffer>(buffer);
		line = start_line; col = start_col - 1; charPos = -1;
		alloc_builder.destroy(oldBuf);
		NextCh();
	}

-->initialization
	initialize_mdl_keywords();
	pt = tokens = CreateToken(); // first token is a dummy
}

void Scanner::NextCh() {
	if (oldEols > 0) { ch = EOL; oldEols--; }
	else {
		pos = buffer->GetPos();
		// buffer reads unicode chars, if UTF8 has been detected
		ch = buffer->Read(); col++; charPos++;
		// replace isolated '\r' by '\n' in order to make
		// eol handling uniform across Windows, Unix and Mac
		if (ch == L'\r' && buffer->Peek() != L'\n') ch = EOL;
		if (ch == EOL) { line++; col = 0; }
	}
-->casing1
}

void Scanner::AddCh() {
	if (tlen >= tvalLength) {
		tvalLength *= 2;
		wchar_t *newBuf = alloc_builder.alloc<wchar_t>(tvalLength);
		memcpy(newBuf, tval, tlen*sizeof(wchar_t));
		alloc_builder.free(tval);
		tval = newBuf;
	}
	if (ch != Buffer::EoF) {
-->casing2
		NextCh();
	}
}

-->comments

Token* Scanner::CreateToken() {
	return arena_builder.create<Token>();
}

void Scanner::AppendVal(Token *t) {
	wchar_t *val = arena_builder.alloc<wchar_t>(tlen + 1);

	wcsncpy(val, tval, tlen);
	val[tlen] = L'\0';
	t->val = val;
}

Token* Scanner::NextToken() {
	while (ch == ' ' ||
-->scan1
	) NextCh();
-->scan2
	int recKind = noSym;
	int recEnd = pos;
	t = CreateToken();
	t->pos = pos; t->col = col; t->line = line; t->charPos = charPos;
	int state = start.state(ch);
	tlen = 0; AddCh();

	switch (state) {
		case -1: { t->kind = eofSym; break; } // NextCh already done
		case 0: {
			case_0:
			if (recKind != noSym) {
				tlen = recEnd - t->pos;
				SetScannerBehindT();
			}
			t->kind = recKind; break;
		} // NextCh already done
-->scan3
	}
	AppendVal(t);
	return t;
}

void Scanner::SetScannerBehindT() {
	buffer->SetPos(t->pos);
	NextCh();
	line = t->line; col = t->col; charPos = t->charPos;
	for (int i = 0; i < tlen; i++) NextCh();
}

void Scanner::UndeterminedComment(int line, int col) {
	errors->Error(line, col, UNDETERMINED_COMMENT, Error_params(arena.get_allocator()));
}

// get the next token (possibly a token already seen during peeking)
Token* Scanner::Scan() {
	if (tokens->next == NULL) {
		return pt = tokens = NextToken();
	} else {
		pt = tokens = tokens->next;
		return tokens;
	}
}

// peek for the next token, ignore pragmas
Token* Scanner::Peek() {
	do {
		if (pt->next == NULL) {
			pt->next = NextToken();
		}
		pt = pt->next;
	} while (pt->kind > maxT); // skip pragmas

	return pt;
}

// make sure that peeking starts at the current scan position
void Scanner::ResetPeek() {
	pt = tokens;
}

-->namespace_close
