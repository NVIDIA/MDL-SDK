/******************************************************************************
 * Copyright (c) 2018-2020, NVIDIA CORPORATION. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  * Neither the name of NVIDIA CORPORATION nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

namespace mi {
namespace mdl {

/*! \page mi_mdl_core_example_execution_ptx Example for Execution of Compiled MDL Materials (PTX)

<div align="right">
    [\link mi_mdl_core_example_calls Previous\endlink]
    [\link mi_mdl_core_examples Up\endlink]
    [\link mi_mdl_core_example_df_cuda Next\endlink]
</div>

This example describes the API of the code generated by the "PTX" backend for compiled materials and shows how a renderer can call this generated code to evaluate sub-expressions of multiple materials using CUDA.

\section example_execution_ptx_new New Topics

  - MDL material state (PTX)
  - Execution of generated code (PTX)
  - Loading textures (PTX)
  - Texture access functions (PTX)

\section example_execution_ptx_descr Detailed Description

<dl>
<dt><b>MDL material state (PTX)</b></dt>
<dd>
The MDL material state structure Shading_state_material is a representation of the renderer state as defined in section 19 "Renderer state" in the MDL specification.
It is used to make the state of the renderer (like the position of an intersection point on the surface, the shading normal and the texture coordinates) available to the generated code.

Here's a version of the material state structure making use of the types from CUDA's \c vector_types.h:

\code
    struct Shading_state_material {
        float3                 normal;                  // state::normal() result
        float3                 geom_normal;             // state::geom_normal() result
        float3                 position;                // state::position() result
        float                  animation_time;          // state::animation_time() result
        float3 const          *text_coords;             // state::texture_coordinate() table
        float3 const          *tangent_u;               // state::texture_tangent_u() table
        float3 const          *tangent_v;               // state::texture_tangent_v() table
        float4                *text_results;            // texture results lookup table
        unsigned char const   *ro_data_segment;         // read-only data segment
        float4 const          *world_to_object;         // world-to-object transform matrix
        float4 const          *object_to_world;         // object-to-world transform matrix
        int                    object_id;               // state::object_id() result
    };
\endcode

Please refer to the structure documentation for more information.

In this example, we fill the material state structure with some example values and only use one texture space.
For the world-to-object and object-to-world transformation matrices we use identity matrices.
We will iterate the \c position and \c text_coords fields over a 2x2 quad around the center of the world with position \c x and \c y coordinates ranging from -1 to 1 and the texture uv-coordinates ranging from 0 to 1, respectively.
</dd>

<dt><b>Execution of generated code (PTX)</b></dt>
<dd><br>
For the non-native backends, the generated code has to be called directly from the corresponding framework, so we need to know the prototypes of the functions generated via \link ILink_unit::add(ILambda_function const *, ICall_name_resolver const *, IGenerated_code_executable::Function_kind, size_t *, size_t *) ILink_unit::add() \endlink.
With \c "NAME" being the function name you provided as \c fname parameter and \c "T" being the result type, they look like this:

\code
    void NAME(
        T                             *result,
        Shading_state_material const  *state,
        Resource_data const           *res_data,
        void const                    *exception_state,
        char const                    *captured_args);
\endcode

or written as a PTX prototype:

\code
.visible .func NAME(
        .param .b64 result,
        .param .b64 state,
        .param .b64 res_data,
        .param .b64 exception_state,
        .param .b64 captured_args
);
\endcode

The \c res_data parameter is used to provide access to resources like textures depending on the way how those resources are accessed (see "Texture access functions" below).
If it is not used, the pointers inside the structure may be NULL:

\code
    struct Resource_data {
        void const                  *shared_data;
        Texture_handler_base const  *texture_handler;
    };
\endcode

The \c exception_state parameter allows to provide handlers for out-of-bounds array access exceptions and division-by-zero exceptions.
But for the PTX backend, this is not supported and the parameter should be set to NULL.

The \c captured_args parameter is used to provide the data of the argument value block for class-compiled materials.
The data can be created using the information from IGenerated_code_value_layout and the IGenerated_code_value_layout::set_value() function.
For instance-compiled materials, this parameter should be set to NULL.
See \ref mdl_material_instances_modes for more details about instance and class compilation.

In this example, we use the \ref mi_mdl_core_example_cuda_shared to generate PTX code for the MDL expressions.
The argument value blocks represented by the \c Argument_block helper class are automatically generated from the compiled materials in \c Material_ptx_compiler::generate_cuda_ptx().

To make the generated functions available to our CUDA kernel, we have to link them with the kernel.
We could just declare the generated functions with the corresponding names as <tt>extern "C"</tt> in the CUDA source code of the kernel, but we may want to decide at runtime how many materials will be available.
So we will add an indirection through an array of pointers to the generated functions which we provide as an additional PTX source code buffer to the CUDA linker.
This PTX source code is generated by \c generate_func_array_ptx().

\note We currently have to add a dummy function to the PTX code containing this function pointer array, because the CUDA linker will otherwise just resolve the function addresses to zero.

\note Also, we need to compile the CUDA kernel with the option \c -rdc=true (relocatable device code), otherwise the \c extern declared function array will be treated as a definition resulting in two arrays.

In this example, we bake multiple materials into a texture with a user-configurable checkerboard pattern by executing a material for every texel updating the material state accordingly.
At the end, we write the texture to disk.
</dd>

<dt><b>Loading textures (PTX)</b></dt>
<dd>
As described in \ref mi_mdl_core_example_cuda_shared, the \c Resource_collection helper class loads the used textures on the host side using FreeImage into \c Texture_data objects.
These can be retrieved via \c Ptx_code::get_texture().
Note, that like in the MDL SDK, the \c Resource_collection helper class always adds an invalid texture as the first texture, if any textures are available.
So only if there is more than just one texture, there will be real referenced textures available.

The textures still have to be copied to the GPU and possibly they have to be gamma corrected and converted to a format understood by the texture access functions you provide.
In this example, we use the \c Material_gpu_context helper class to prepare all data for the GPU and manage the resources on the device.
Due to limitations of FreeImage, it currently only supports 2D textures.
The \c Material_gpu_context::prepare_texture() function does the gamma correction, if necessary, copies the image data to a CUDA array and makes the texture available on the device via a CUDA texture object.
</dd>

<dt><b>Texture access functions (PTX)</b></dt>
<dd><br>
For non-native backends, the generated code requires a set of methods implementing texture access functionality:

- tex_lookup_float4_2d

- tex_lookup_float3_2d

- tex_texel_float4_2d

- tex_lookup_float4_3d

- tex_lookup_float3_3d

- tex_texel_float4_3d

- tex_lookup_float4_cube

- tex_lookup_float3_cube

- tex_resolution_2d

Except for the last one, these correspond directly to the functions described in section 20.3 "Standard library functions - Texture" in the MDL specification.

The \c tex_lookup_* functions receive floating-point texture coordinates and should provide
a sampled value, whereas \c tex_texel_* functions receive integer texture coordinates and
should provide a raw texture value. There are variants for texture lookups with and without
alpha channel (float4 / float3) and for the different texture shapes (2d / 3d / cube) as
described in section 6.12 "Variables and data types - Textures" in the MDL specification.
Note, that PTEX textures are currently not supported by the backends.

\c tex_resolution_2d retrieves the width and height at the given uv-tile coordinates for a texture_2d.
For non-uv-tile textures, the uv-tile coordinates are always (0, 0).

For the PTX backend, there are different ways how the methods can be provided, which can be chosen by setting the \c MDL_JIT_OPTION_TEX_LOOKUP_CALL_MODE option on the Options object returned by ICode_generator_jit::access_options().
Please refer to \ref mi_mdl_core_ptx_texture_lookup_call_modes for more details.

In this example, you can switch from the \c "direct_call" mode to the slower \c "vtable" mode by commenting out this line in \c example_cuda_shared.h:

\code
    options.set_option(MDL_JIT_OPTION_TEX_LOOKUP_CALL_MODE, "direct_call");
\endcode
</dd>
</dl>

\section example_execution_ptx Example Source

To compile the source code, you need to install the "CUDA Toolkit 9" available at <a href="https://developer.nvidia.com/cuda-downloads">https://developer.nvidia.com/cuda-downloads</a>.

For Windows, you should install the toolkit with enabled Visual Studio integration to be able to use the provided project files.

For Linux and Mac OS X, you have to provide the path to the CUDA Toolkit installation via a \c "CUDA_PATH" environment variable or by setting the path in the \c Makefile.

<b>Source Code Location:</b>
  <tt>examples/mdl_core/execution_cuda/example_execution_cuda.cpp</tt>

\include execution_cuda/example_execution_cuda.cpp

<b>Source Code Location:</b>
  <tt>examples/mdl_core/shared/texture_support_cuda.h</tt>

\include shared/texture_support_cuda.h

<b>Source Code Location:</b>
  <tt>examples/mdl_core/shared/example_cuda_shared.h</tt>

\include shared/example_cuda_shared.h

<b>Source Code Location:</b>
  <tt>examples/mdl_core/execution_cuda/example_execution_cuda.cu</tt>

\include execution_cuda/example_execution_cuda.cu

<div align="right">
    [\link mi_mdl_core_example_calls Previous\endlink]
    [\link mi_mdl_core_examples Up\endlink]
    [\link mi_mdl_core_example_df_cuda Next\endlink]
</div>

*/

}
}
