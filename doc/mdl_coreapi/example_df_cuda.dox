/******************************************************************************
 * Copyright (c) 2018-2025, NVIDIA CORPORATION. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  * Neither the name of NVIDIA CORPORATION nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

namespace mi {
namespace mdl {

/*! \page mi_mdl_core_example_df_cuda Example for Compiled Distribution Functions (PTX)

<div align="right">
    [\link mi_mdl_core_example_execution_ptx Previous\endlink]
    [\link mi_mdl_core_examples Up\endlink]
    [\link mi_mdl_core_example_derivatives Next\endlink]
</div>

This example shows how functions implementing BSDFs can be generated by the "PTX" backend.
To illustrate the use of these functions in CUDA, it implements a small physically based renderer that computes direct lighting from an HDR environment map using BSDF evaluation and importance sampling.

\section example_df_cuda_new New Topics

  - Generated BSDF functions
  - Changing compiled material arguments at runtime

\section example_df_cuda_descr Detailed Description

<dl>
<dt><b>BSDF functions</b></dt>
<dd>
The generated functions for BSDFs implement

  - An initialization function to prepare shared data per hit.
  - Evaluation of the BSDF for a given pair of incoming and outgoing directions.
  - Importance sampling of an incoming direction given an outgoing direction.
  - Probability density function (PDF) computation of generating an incoming for a given outgoing direction.

Each function takes arguments for state, resources, and material arguments that are analogous to the material expression counterpart of the earlier examples and the latter three functions further take a specific input and output parameter \c data.
The signatures of the functions are:
\code
typedef void (Bsdf_init_function)(
    Shading_state_material *state,
    Resource_data const    *res_data,
    void const             *exception_state,
    char const             *arg_block_data);

typedef void (Bsdf_sample_function)(
    Bsdf_sample_data             *data,
    Shading_state_material const *state,
    Resource_data const          *res_data,
    void const                   *exception_state,
    char const                   *arg_block_data);

typedef void (Bsdf_evaluate_function)(
    Bsdf_evaluate_data           *data,
    Shading_state_material const *state,
    Resource_data const          *res_data,
    void const                   *exception_state,
    char const                   *arg_block_data);

typedef void (Bsdf_pdf_function)(
    Bsdf_pdf_data                *data,
    Shading_state_material const *state,
    Resource_data const          *res_data,
    void const                   *exception_state,
    char const                   *arg_block_data);
\endcode
The functions can be generated by \link ILink_unit::add(IDistribution_function const *, IModule_cache *, ICall_name_resolver const *, size_t *, size_t *, size_t) ILink_unit::add() \endlink.
Both functions have a parameter \c include_geometry_normal that can be specified to make the initialization function replace \c state->normal by the result of the expression connected to \c geometry.normal of the material.
The final function names are specified by a base name that will suffixed by \c _init, \c _sample, \c _evaluate, and \c _pdf.

BSDF evaluation and PDF computation take a pair of directions and IORs (index of refraction) as input and produce a PDF and, in the case of \c Bsdf_evaluate_function, the value of the BSDF. The corresponding structs are

\code

struct Bsdf_evaluate_data {
    // Input fields
    float3       ior1;           // IOR current medium
    float3       ior2;           // IOR other side
    float3       k1;             // outgoing direction
    float3       k2;             // incoming direction

    // Output fields
    float3       bsdf;           // bsdf * dot(normal, k2)
    float        pdf;            // pdf (non-projected hemisphere)
};

/// Input and output structure for BSDF PDF calculation data.
struct Bsdf_pdf_data {
    // Input fields
    float3       ior1;           // IOR current medium
    float3       ior2;           // IOR other side
    float3       k1;             // outgoing direction
    float3       k2;             // incoming direction

    // Output fields
    float        pdf;            // pdf (non-projected hemisphere)
};

\endcode

The handling of the (color) IOR is generally up to the renderer, in particular this includes the decision if the evaluation should happen from within an object with refracting material or from the outer side.
It is possible though, to just pass in one IOR (e.g. \c ior1) and make the functions fill the other with the IOR of the material by marking the \c x component of it with \c MDL_CORE_BSDF_USE_MATERIAL_IOR (e.g. \c ior2.x=MDL_CORE_BSDF_USE_MATERIAL_IOR).

For importance sampling, one direction and a set of pseudo-random numbers needs to be provided. The output values include the importance sampled direction, a PDF, a weight (the value of the BSDF divided by the PDF), and the type of the BSDF that was eventually sampled. Note that this may include an absorption event, in which case no direction has been generated.

\code
enum Bsdf_event_type {
    BSDF_EVENT_ABSORB       = 0,

    BSDF_EVENT_DIFFUSE      = 1,
    BSDF_EVENT_GLOSSY       = 1 << 1,
    BSDF_EVENT_SPECULAR     = 1 << 2,
    BSDF_EVENT_REFLECTION   = 1 << 3,
    BSDF_EVENT_TRANSMISSION = 1 << 4,

    BSDF_EVENT_DIFFUSE_REFLECTION    = BSDF_EVENT_DIFFUSE  | BSDF_EVENT_REFLECTION,
    BSDF_EVENT_DIFFUSE_TRANSMISSION  = BSDF_EVENT_DIFFUSE  | BSDF_EVENT_TRANSMISSION,
    BSDF_EVENT_GLOSSY_REFLECTION     = BSDF_EVENT_GLOSSY   | BSDF_EVENT_REFLECTION,
    BSDF_EVENT_GLOSSY_TRANSMISSION   = BSDF_EVENT_GLOSSY   | BSDF_EVENT_TRANSMISSION,
    BSDF_EVENT_SPECULAR_REFLECTION   = BSDF_EVENT_SPECULAR | BSDF_EVENT_REFLECTION,
    BSDF_EVENT_SPECULAR_TRANSMISSION = BSDF_EVENT_SPECULAR | BSDF_EVENT_TRANSMISSION,
};

struct Bsdf_sample_data {
    // Input fields
    float3           ior1;           // IOR current medium
    float3           ior2;           // IOR other side
    float3           k1;             // outgoing direction
    float3           xi;             // pseudo-random sample number

    // Output fields
    float3           k2;             // incoming direction
    float            pdf;            // pdf (non-projected hemisphere)
    float3           bsdf_over_pdf;  // bsdf * dot(normal, k2) / pdf
    Bsdf_event_type  event_type;     // the type of event for the generated sample
};

\endcode

It often is the case that for a given shading point both evaluation and importance sampling need to be performed (possibly multiple times).
To avoid re-computation of material expressions in each BSDF function call it is essential that the results are cached between multiple calls.
This is accomplished by the initialization function \c Bsdf_init_function which stores computed results in an array passed by the Shading_state_material::text_results field.
The size of that array needs to be communicated to the backend using the \c "num_texture_results" parameter of the used functions of ICode_generator_jit.
If the storage is insufficient (e.g. for a material with a high number of material expressions), non-cached expressions are automatically recomputed when they are needed.
The initialization is generally not optional, i.e. even if the \c text_results array size is set to zero it may still perform some initialization, in particular it will update \c state->normal if requested.
</dd>

<dt><b>Changing arguments of class-compiled materials at runtime</b></dt>
<dd>
As explained in \ref mdl_material_instances_modes, the resulting IGenerated_code_executable object contains IGenerated_code_value_layout objects for each material, when class-compiled materials are used for generating target code.
Together with the corresponding IGenerated_code_dag::IMaterial_instance, you can already get some information about the arguments:

 - the names via IGenerated_code_dag::IMaterial_instance::get_parameter_name(),
 - the types by calling IValue::get_type() on the default parameters of the material instance returned by IGenerated_code_dag::IMaterial_instance::get_parameter_default(), and
 - the offsets in the argument block by calling IGenerated_code_value_layout::get_layout() with the states returned by IGenerated_code_value_layout::get_nested_state().

The example uses this information to build a material editor GUI with the "Dear ImGui" framework (<a href="https://github.com/ocornut/imgui">https://github.com/ocornut/imgui</a>).
The GUI controls are linked to the data of the target argument block using the offsets of the arguments.
When ImGui reports any changes by the user, the target argument block is updated on the device for the current material.

When presenting material arguments to the user, additional information from parameter annotations may improve the user experience.
To find the annotations for an argument of a material instance, you have to look up the parameter index for this name in the DAG using IGenerated_code_dag::get_material_parameter_index().
Then you can iterate over the parameter annotations via IGenerated_code_dag::get_material_parameter_annotation() and IGenerated_code_dag::get_material_parameter_annotation_count().

\note You will only find a parameter in a material definition with an exactly matching name for a compiled material argument, when non-struct constants were used as arguments during class-compilation.
For other arguments you will get paths like "x.b" as parameter names.

In this example, the \c anno::hard_range annotation is used to determine the minimum and maximum values for value sliders, the \c anno::display_name annotation is used as a more user-friendly name for the arguments, and the \c anno::in_group annotation is used to group the arguments into categories.

</dd>
</dl>

\section example_df_cuda Example Source

To compile the source code, you require CUDA, GLFW, and GLEW.

<b>Source Code Location:</b>
  <tt>examples/mdl_core/df_cuda/example_df_cuda.cpp</tt>

\include df_cuda/example_df_cuda.cpp

<b>Source Code Location:</b>
  <tt>examples/mdl_core/df_cuda/example_df_cuda.h</tt>

\include df_cuda/example_df_cuda.h

<b>Source Code Location:</b>
  <tt>examples/mdl_core/shared/texture_support_cuda.h</tt>

\include shared/texture_support_cuda.h

<b>Source Code Location:</b>
  <tt>examples/mdl_core/shared/example_cuda_shared.h</tt>

\include shared/example_cuda_shared.h

<b>Source Code Location:</b>
  <tt>examples/mdl_core/df_cuda/example_df_cuda.cu</tt>

\include df_cuda/example_df_cuda.cu


<div align="right">
    [\link mi_mdl_core_example_execution_ptx Previous\endlink]
    [\link mi_mdl_core_examples Up\endlink]
    [\link mi_mdl_core_example_derivatives Next\endlink]
</div>

*/

}
}
