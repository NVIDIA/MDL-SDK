/******************************************************************************
 * Copyright (c) 2018-2025, NVIDIA CORPORATION. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  * Neither the name of NVIDIA CORPORATION nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

/*! \page mi_neuray_example_df_cuda Example for Compiled Distribution Functions (PTX)

<div align="right">
    [\link mi_neuray_example_execution_glsl_vk Previous\endlink]
    [\link mi_neuray_examples Up\endlink]
    [\link mi_neuray_example_df_native Next\endlink]
</div>

This example shows how functions implementing BSDFs can be generated by the "PTX" backend.
To illustrate the use of these functions in CUDA, it implements a small physically based renderer that computes direct lighting from an HDR environment map using BSDF evaluation and importance sampling.

\section example_df_cuda_new New Topics

  - Generated BSDF functions
  - Changing compiled material arguments at runtime

\section example_df_cuda_descr Detailed Description

<dl>
<dt><b>BSDF functions</b></dt>
<dd><br>
The generated functions for BSDFs implement

  - An initialization function to prepare shared data per hit.
  - Evaluation of the BSDF for a given pair of incoming and outgoing directions.
  - Importance sampling of an incoming direction given an outgoing direction.
  - Probability density function (PDF) computation of generating an incoming for a given outgoing direction.

Each function takes arguments for state, resources, and material arguments that are analogous to the material expression counterpart of the earlier examples and the latter three functions further take a specific input and output parameter \c data.
The signatures of the functions look like this:
\code
typedef void (Bsdf_init_function)    (Shading_state_material *state,
                                      const Resource_data *res_data,
                                      const void *exception_state,
                                      const char *arg_block_data);

typedef void (Bsdf_sample_function)  (Bsdf_sample_data *data,
                                      const Shading_state_material *state,
                                      const Resource_data *res_data,
                                      const void *exception_state,
                                      const char *arg_block_data);

typedef void (Bsdf_evaluate_function)(Bsdf_evaluate_data *data,
                                      const Shading_state_material *state,
                                      const Resource_data *res_data,
                                      const void *exception_state,
                                      const char *arg_block_data);
                                      
typedef void (Bsdf_pdf_function)     (Bsdf_pdf_data *data,
                                      const Shading_state_material *state,
                                      const Resource_data *res_data,
                                      const void *exception_state,
                                      const char *arg_block_data);
\endcode
The functions can be generated by #mi::neuraylib::IMdl_backend::translate_material_df(), #mi::neuraylib::IMdl_backend::translate_material(), #mi::neuraylib::ILink_unit::add_material_df() or #mi::neuraylib::ILink_unit::add_material().
All functions support the context option \c include_geometry_normal that can be specified to make the initialization function replace \c state->normal by the result of the expression connected to \c geometry.normal of the material.
The default for this option is \c true.
The final function names are specified by a base name that will suffixed by \c _init, \c _sample, \c _evaluate, and \c _pdf.

If you use #mi::neuraylib::IMdl_backend::translate_material() or #mi::neuraylib::ILink_unit::add_material(), you can also enable the single-init mode, by specifying the special "init" expression path as first element in the function description list.
In this mode, only one \c init function will be generated precalculating values for all requested expressions.

BSDF evaluation and PDF computation take a pair of directions and IORs (index of refraction) as input and produce a PDF and, in the case of \c Bsdf_evaluate_function, the value of the BSDF. The corresponding structs are

\code

struct Bsdf_evaluate_data {
    // Input fields
    float3       ior1;           // IOR current medium
    float3       ior2;           // IOR other side
    float3       k1;             // outgoing direction
    float3       k2;             // incoming direction

    // Output fields
    float3       bsdf;           // bsdf * dot(normal, k2)
    float        pdf;            // pdf (non-projected hemisphere)
};

/// Input and output structure for BSDF PDF calculation data.
struct Bsdf_pdf_data {
    // Input fields
    float3       ior1;           // IOR current medium
    float3       ior2;           // IOR other side
    float3       k1;             // outgoing direction
    float3       k2;             // incoming direction

    // Output fields
    float        pdf;            // pdf (non-projected hemisphere)
};

\endcode

The handling of the (color) IOR is generally up to the renderer, in particular this includes the decision if the evaluation should happen from within an object with refracting material or from the outer side.
It is possible though, to just pass in one IOR (e.g. \c ior1) and make the functions fill the other with the IOR of the material by marking the \c x component of it with \c MI_NEURAYLIB_BSDF_USE_MATERIAL_IOR (e.g. \c ior2.x=MI_NEURAYLIB_BSDF_USE_MATERIAL_IOR).

For importance sampling, one direction and a set of pseudo-random numbers needs to be provided. The output values include the importance sampled direction, a PDF, a weight (the value of the BSDF divided by the PDF), and the type of the BSDF that was eventually sampled. Note that this may include an absorption event, in which case no direction has been generated.

\code
enum Bsdf_event_type {
    BSDF_EVENT_ABSORB       = 0,

    BSDF_EVENT_DIFFUSE      = 1,
    BSDF_EVENT_GLOSSY       = 1 << 1,
    BSDF_EVENT_SPECULAR     = 1 << 2,
    BSDF_EVENT_REFLECTION   = 1 << 3,
    BSDF_EVENT_TRANSMISSION = 1 << 4,

    BSDF_EVENT_DIFFUSE_REFLECTION    = BSDF_EVENT_DIFFUSE  | BSDF_EVENT_REFLECTION,
    BSDF_EVENT_DIFFUSE_TRANSMISSION  = BSDF_EVENT_DIFFUSE  | BSDF_EVENT_TRANSMISSION,
    BSDF_EVENT_GLOSSY_REFLECTION     = BSDF_EVENT_GLOSSY   | BSDF_EVENT_REFLECTION,
    BSDF_EVENT_GLOSSY_TRANSMISSION   = BSDF_EVENT_GLOSSY   | BSDF_EVENT_TRANSMISSION,
    BSDF_EVENT_SPECULAR_REFLECTION   = BSDF_EVENT_SPECULAR | BSDF_EVENT_REFLECTION,
    BSDF_EVENT_SPECULAR_TRANSMISSION = BSDF_EVENT_SPECULAR | BSDF_EVENT_TRANSMISSION,
};

struct Bsdf_sample_data {
    // Input fields
    float3       ior1;           // IOR current medium
    float3       ior2;           // IOR other side
    float3       k1;             // outgoing direction
    float3       xi;             // pseudo-random sample number

    // Output fields
    float3       k2;             // incoming direction
    float        pdf;            // pdf (non-projected hemisphere)
    float3       bsdf_over_pdf;  // bsdf * dot(normal, k2) / pdf
    Bsdf_event_type  event_type; // the type of event for the generated sample
};

\endcode

It often is the case that for a given shading point both evaluation and importance sampling need to be performed (possibly multiple times).
To avoid re-computation of material expressions in each BSDF function call it is essential that the results are cached between multiple calls.
This is accomplished by the initialization function \c Bsdf_init_function which stores computed results in an array passed by the #mi::neuraylib::Shading_state_material::text_results field.
The size of that array needs to be communicated to the backend using the \c "num_texture_results" option via #mi::neuraylib::IMdl_backend::set_option().
If the storage is insufficient (e.g. for a material with a high number of material expressions), non-cached expressions are automatically recomputed when they are needed.
The initialization is generally not optional, i.e. even if the \c text_results array size is set to zero it may still perform some initialization, in particular it will update \c state->normal if requested.
</dd>

<dt><b>EDF functions</b></dt>
<dd><br>
Analogous to the generation of BSDF functions, emission distribution functions (EDFs) can be generated using the corresponding signatures and data structures.
For more information see the example code and run the example application using materials that contain EDFs:

\code
df_cuda ::nvidia::sdk_examples::tutorials::example_edf
df_cuda ::nvidia::sdk_examples::tutorials::example_measured_edf
\endcode

Global distributions are not supported yet and result in no emission. Hence, the generated EDFs can currently be evaluated only in tangent space.

</dd>

<dt><b>Changing arguments of class-compiled materials at runtime</b></dt>
<dd><br>
As explained in \ref mi_neuray_compilation_modes, the resulting #mi::neuraylib::ITarget_code object contains #mi::neuraylib::ITarget_value_layout and #mi::neuraylib::ITarget_argument_block objects for each material, when class-compiled materials are used for generating target code.
Together with the corresponding #mi::neuraylib::ICompiled_material, you can already get some information about the arguments:

 - the names via #mi::neuraylib::ICompiled_material::get_parameter_name(),
 - the types by calling #mi::neuraylib::IValue::get_type() on the arguments returned by #mi::neuraylib::ICompiled_material::get_argument(), and
 - the offsets in the argument block by calling #mi::neuraylib::ITarget_value_layout::get_layout() with the states returned by #mi::neuraylib::ITarget_value_layout::get_nested_state().

The example uses this information to build a material editor GUI with the "Dear ImGui" framework (<a href="https://github.com/ocornut/imgui">https://github.com/ocornut/imgui</a>).
The GUI controls are linked to the data of the target argument block using the offsets of the arguments.
When ImGui reports any changes by the user, the target argument block is updated on the device for the current material.

When presenting material arguments to the user, additional information from parameter annotations may improve the user experience.
To find the annotations for an argument of a compiled material, you have to look up the annotation block for a parameter of the corresponding #mi::neuraylib::IFunction_definition with the same name as the argument.

\note You will only find a parameter in a material definition with an exactly matching name for a compiled material argument, when non-struct constants were used as arguments during class-compilation.
For other arguments you will get paths like "x.b" as parameter names.

In this example, the \c anno::hard_range annotation is used to determine the minimum and maximum values for value sliders, the \c anno::display_name annotation is used as a more user-friendly name for the arguments, and the \c anno::in_group annotation is used to group the arguments into categories.

</dd>
</dl>

\section example_df_cuda Example Source

To compile the source code, you require CUDA, GLFW, and GLEW.
For detailed instructions, please refer to the \link mi_neuray_getting_started Getting Started \endlink section.

<b>Source Code Location:</b>
  <tt>examples/mdl_sdk/df_cuda/example_df_cuda.cpp</tt>

\include df_cuda/example_df_cuda.cpp

<b>Source Code Location:</b>
  <tt>examples/mdl_sdk/df_cuda/example_df_cuda.h</tt>

\include df_cuda/example_df_cuda.h

<b>Source Code Location:</b>
  <tt>examples/mdl_sdk/shared/texture_support_cuda.h</tt>

\include shared/texture_support_cuda.h

<b>Source Code Location:</b>
  <tt>examples/mdl_sdk/shared/example_cuda_shared.h</tt>

\include shared/example_cuda_shared.h

<b>Source Code Location:</b>
  <tt>examples/mdl_sdk/df_cuda/example_df_cuda.cu</tt>

\include df_cuda/example_df_cuda.cu


<div align="right">
    [\link mi_neuray_example_execution_glsl_vk Previous\endlink]
    [\link mi_neuray_examples Up\endlink]
    [\link mi_neuray_example_df_native Next\endlink]
</div>

*/
